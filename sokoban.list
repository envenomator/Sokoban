ca65 V2.19 - Git fcda94f25
Main file   : sokoban.asm
Current file: sokoban.asm

000000r 1               .include "x16.inc"
000000r 2               .ifndef X16_INC
000000r 2               X16_INC  = 1
000000r 2               
000000r 2               .ifndef __CX16__
000000r 2               __CX16__ = 1
000000r 2               .endif
000000r 2               
000000r 2               SD_DEVICE   = 1
000000r 2               HOST_DEVICE = 8
000000r 2               DISK_DEVICE = HOST_DEVICE
000000r 2               
000000r 2               
000000r 2               ; RAM Addresses
000000r 2               
000000r 2               ; Kernal Registers
000000r 2               r0						= $02
000000r 2               r0L					= r0
000000r 2               r0H					= r0+1
000000r 2               r1						= $04
000000r 2               r1L					= r1
000000r 2               r1H					= r1+1
000000r 2               r2						= $06
000000r 2               r2L					= r2
000000r 2               r2H					= r2+1
000000r 2               r3						= $08
000000r 2               r3L					= r3
000000r 2               r3H					= r3+1
000000r 2               r4						= $0A
000000r 2               r4L					= r4
000000r 2               r4H					= r4+1
000000r 2               r5						= $0C
000000r 2               r5L					= r5
000000r 2               r5H					= r5+1
000000r 2               r6						= $0E
000000r 2               r6L					= r6
000000r 2               r6H					= r6+1
000000r 2               r7						= $10
000000r 2               r7L					= r7
000000r 2               r7H					= r7+1
000000r 2               r8						= $12
000000r 2               r8L					= r8
000000r 2               r8H					= r8+1
000000r 2               r9						= $14
000000r 2               r9L					= r9
000000r 2               r9H					= r9+1
000000r 2               r10					= $16
000000r 2               r10L					= r10
000000r 2               r10H					= r10+1
000000r 2               r11					= $18
000000r 2               r11L					= r11
000000r 2               r11H					= r11+1
000000r 2               r12					= $1A
000000r 2               r12L					= r12
000000r 2               r12H					= r12+1
000000r 2               r13					= $1C
000000r 2               r13L					= r13
000000r 2               r13H					= r13+1
000000r 2               r14					= $1E
000000r 2               r14L					= r14
000000r 2               r14H					= r14+1
000000r 2               r15					= $20
000000r 2               r15L					= r15
000000r 2               r15H					= r15+1
000000r 2               
000000r 2               ; Zero-Page userspace
000000r 2               ZP_PTR_1          = $22	; first four pointers for temporary use only
000000r 2               ZP_PTR_2          = $24
000000r 2               ZP_PTR_3          = $26
000000r 2               ZP_PTR_4          = $28
000000r 2               
000000r 2               ; I/O Registers
000000r 2               VERA_addr_low     = $9F20
000000r 2               VERA_addr_high    = $9F21
000000r 2               VERA_addr_bank    = $9F22
000000r 2               VERA_data0        = $9F23
000000r 2               VERA_data1        = $9F24
000000r 2               VERA_ctrl         = $9F25
000000r 2               VERA_ien          = $9F26
000000r 2               VERA_isr          = $9F27
000000r 2               VERA_irqline_l    = $9F28
000000r 2               VERA_dc_video     = $9F29
000000r 2               VERA_dc_hscale    = $9F2A
000000r 2               VERA_dc_vscale    = $9F2B
000000r 2               VERA_dc_border    = $9F2C
000000r 2               VERA_dc_hstart    = $9F29
000000r 2               VERA_dc_hstop     = $9F2A
000000r 2               VERA_dc_vsstart   = $9F2B
000000r 2               VERA_dc_vstop     = $9F2C
000000r 2               VERA_L0_config    = $9F2D
000000r 2               VERA_L0_mapbase   = $9F2E
000000r 2               VERA_L0_tilebase  = $9F2F
000000r 2               VERA_L0_hscroll_l = $9F30
000000r 2               VERA_L0_hscroll_h = $9F31
000000r 2               VERA_L0_vscroll_l = $9F32
000000r 2               VERA_L0_vscroll_h = $9F33
000000r 2               VERA_L1_config    = $9F34
000000r 2               VERA_L1_mapbase   = $9F35
000000r 2               VERA_L1_tilebase  = $9F36
000000r 2               VERA_L1_hscroll_l = $9F37
000000r 2               VERA_L1_hscroll_h = $9F38
000000r 2               VERA_L1_vscroll_l = $9F39
000000r 2               VERA_L1_vscroll_h = $9F3A
000000r 2               VERA_audio_ctrl   = $9F3B
000000r 2               VERA_audio_rate   = $9F3C
000000r 2               VERA_audio_data   = $9F3D
000000r 2               VERA_spi_data     = $9F3E
000000r 2               VERA_spi_ctrl     = $9F3F
000000r 2               
000000r 2               
000000r 2               ROM_BANK          = $9F60
000000r 2               RAM_BANK          = $9F61
000000r 2               
000000r 2               YM_reg            = $9FE0
000000r 2               YM_data           = $9FE1
000000r 2               
000000r 2               ; Emulator Registers
000000r 2               GIF_ctrl          = $9FB5
000000r 2               
000000r 2               ; ROM Banks
000000r 2               KERNAL_ROM_BANK   = 0
000000r 2               BASIC_ROM_BANK    = 4
000000r 2               
000000r 2               ; Banked Addresses
000000r 2               RAM_WIN           = $A000
000000r 2               RAM_WIN_SIZE      = $2000
000000r 2               ROM_WIN           = $C000
000000r 2               
000000r 2               ; Kernal Subroutines
000000r 2               CONSOLE_set_paging_message		:= $FED5
000000r 2               CONSOLE_put_image					:= $FED8
000000r 2               CONSOLE_init						:= $FEDB
000000r 2               CONSOLE_put_char					:= $FEDE
000000r 2               CONSOLE_get_char					:= $FEE1
000000r 2               MEMORY_FILL                   := $FEE4
000000r 2               MEMORY_COPY                   := $FEE7
000000r 2               MEMORY_CRC                    := $FEEA
000000r 2               MEMORY_DECOMPRESS             := $FEED
000000r 2               SPRITE_set_image					:= $FEF0
000000r 2               SPRITE_set_position				:= $FEF3
000000r 2               FB_init                 		:= $FEF6
000000r 2               FB_get_info             		:= $FEF9
000000r 2               FB_set_palette          		:= $FEFC
000000r 2               FB_cursor_position      		:= $FEFF
000000r 2               FB_cursor_next_line     		:= $FF02
000000r 2               FB_get_pixel            		:= $FF05
000000r 2               FB_get_pixels           		:= $FF08
000000r 2               FB_set_pixel            		:= $FF0B
000000r 2               FB_set_pixels           		:= $FF0E
000000r 2               FB_set_8_pixels         		:= $FF11
000000r 2               FB_set_8_pixels_opaque  		:= $FF14
000000r 2               FB_fill_pixels          		:= $FF17
000000r 2               FB_filter_pixels        		:= $FF1A
000000r 2               FB_move_pixels          		:= $FF1D
000000r 2               GRAPH_init							:= $FF20
000000r 2               GRAPH_clear							:= $FF23
000000r 2               GRAPH_set_window					:= $FF26
000000r 2               GRAPH_set_colors					:= $FF29
000000r 2               GRAPH_draw_line					:= $FF2C
000000r 2               GRAPH_draw_rect					:= $FF2F
000000r 2               GRAPH_move_rect					:= $FF32
000000r 2               GRAPH_draw_oval					:= $FF35
000000r 2               GRAPH_draw_image					:= $FF38
000000r 2               GRAPH_set_font						:= $FF3B
000000r 2               GRAPH_get_char_size				:= $FF3E
000000r 2               GRAPH_put_char						:= $FF41
000000r 2               MONITOR								:= $FF44
000000r 2               ENTER_BASIC							:= $FF47
000000r 2               CLOCK_SET_DATE_TIME           := $FF4D
000000r 2               CLOCK_GET_DATE_TIME           := $FF50
000000r 2               JOYSTICK_SCAN                 := $FF53
000000r 2               JOYSTICK_GET                  := $FF56
000000r 2               SCREEN_SET_MODE					:= $FF5F
000000r 2               SCREEN_SET_CHARSET				:= $FF62
000000r 2               
000000r 2               MOUSE_CONFIG                  := $FF68
000000r 2               MOUSE_GET			            := $FF6B
000000r 2               MOUSE_SCAN                    := $FF71
000000r 2               SCINIT                        := $FF81
000000r 2               IOINIT                        := $FF84
000000r 2               RAMTAS                        := $FF87
000000r 2               RESTOR                        := $FF8A
000000r 2               SETLFS                        := $FFBA
000000r 2               SETNAM                        := $FFBD
000000r 2               OPEN                          := $FFC0
000000r 2               CLOSE                         := $FFC3
000000r 2               CHKIN                         := $FFC6
000000r 2               CHKOUT                        := $FFC9
000000r 2               CLRCHN                        := $FFCC
000000r 2               CHRIN                         := $FFCF
000000r 2               CHROUT                        := $FFD2
000000r 2               LOAD                          := $FFD5
000000r 2               SAVE                          := $FFD8
000000r 2               SETTIM                        := $FFDB
000000r 2               RDTIM                         := $FFDE
000000r 2               STOP                          := $FFE1
000000r 2               GETIN                         := $FFE4
000000r 2               CLALL									:= $FFE7
000000r 2               UDTIM									:= $FFEA
000000r 2               SCREEN								:= $FFED
000000r 2               PLOT									:= $FFF0
000000r 2               IOBASE								:= $FFF3
000000r 2               
000000r 2               ; BASIC Vectors
000000r 2               BASIC_PANIC       := $C000
000000r 2               BASIC_INIT        := $C003
000000r 2               
000000r 2               
000000r 2               ; VRAM Addresses
000000r 2               VRAM_petscii   = $0F000
000000r 2               VRAM_psg       = $1F9C0
000000r 2               VRAM_palette   = $1FA00
000000r 2               VRAM_sprattr   = $1FC00
000000r 2               
000000r 2               ; IRQs
000000r 2               IRQVec         := $0314
000000r 2               BRKVec         := $0316
000000r 2               NMIVec         := $0318
000000r 2               
000000r 2               ;   Macros
000000r 2               
000000r 2               .macro VERA_SET_ADDR addr, stride
000000r 2               	.ifnblank stride
000000r 2                     .if stride < 0
000000r 2                        lda #((^addr) | $08 | ((0-stride) << 4))
000000r 2                     .else
000000r 2                        lda #((^addr) | (stride << 4))
000000r 2                     .endif
000000r 2               	.else
000000r 2               		lda #(^addr) | $10
000000r 2               	.endif
000000r 2               
000000r 2               	sta VERA_addr_bank
000000r 2               	lda #(>addr)
000000r 2               	sta VERA_addr_high
000000r 2               	lda #(<addr)
000000r 2               	sta VERA_addr_low
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               .endif
000000r 2               
000000r 1               
000000r 1               ; constants
000000r 1               NEWLINE = $0D
000000r 1               UPPERCASE = $8E
000000r 1               CLEARSCREEN = 147
000000r 1               LEVELHEADER = 12
000000r 1               MAXUNDO = 10
000000r 1               SCREENWIDTH = 40        ; screen width/height in 16x16 tiles
000000r 1               SCREENHEIGHT = 30
000000r 1               RAMBANK = $a000         ; Ram Bank 0
000000r 1               
000000r 1               .org $080D
00080D  1               .segment "STARTUP"
00080D  1               .segment "INIT"
00080D  1               .segment "ONCE"
00080D  1               .segment "CODE"
00080D  1               
00080D  1               ; VERA Registers
00080D  1               VERA_LOW            = $9F20
00080D  1               VERA_MID            = $9F21
00080D  1               VERA_HIGH           = $9F22
00080D  1               VERA_DATA0          = $9F23
00080D  1               VERA_CTRL           = $9F25
00080D  1               
00080D  1  4C 42 09        jmp start
000810  1               
000810  1               ; string constants
000810  1  52 45 41 4C  quitaskmessage:      .byte "really quit? y/n",0
000814  1  4C 59 20 51  
000818  1  55 49 54 3F  
000821  1  53 45 4C 45  selectmessage:    .byte "select a level (1-",0
000825  1  43 54 20 41  
000829  1  20 4C 45 56  
000834  1  29 3A 20 00  selectendmessage: .byte "): ",0
000838  1  20 20 20 20  clear:            .byte "                                        ",0
00083C  1  20 20 20 20  
000840  1  20 20 20 20  
000861  1  52 45 41 4C  resetmessage:     .byte "really reset level? y/n",0
000865  1  4C 59 20 52  
000869  1  45 53 45 54  
000879  1  50 52 45 53  quitmessage:      .byte "press q to quit",0
00087D  1  53 20 51 20  
000881  1  54 4F 20 51  
000889  1  4C 45 56 45  winstatement:     .byte "level complete! new level? y/n",0
00088D  1  4C 20 43 4F  
000891  1  4D 50 4C 45  
0008A8  1  28 43 29 32  help0:            .byte "(c)2021 venom",0
0008AC  1  30 32 31 20  
0008B0  1  56 45 4E 4F  
0008B6  1  4B 45 59 42  help1:            .byte "keyboard shortcuts:",0
0008BA  1  4F 41 52 44  
0008BE  1  20 53 48 4F  
0008CA  1  43 55 52 53  help2:            .byte "cursor - moves player",0
0008CE  1  4F 52 20 2D  
0008D2  1  20 4D 4F 56  
0008E0  1  20 20 20 20  help3:            .byte "     q - quit",0
0008E4  1  20 51 20 2D  
0008E8  1  20 51 55 49  
0008EE  1  20 20 20 20  help4:            .byte "     u - undo move(s)",0
0008F2  1  20 55 20 2D  
0008F6  1  20 55 4E 44  
000904  1  20 20 20 20  help5:            .byte "     r - reset level",0
000908  1  20 52 20 2D  
00090C  1  20 52 45 53  
000919  1  4D 28 45 4E  done0:            .byte "m(enu)",0
00091D  1  55 29 00     
000920  1  4E 28 45 58  done1:            .byte "n(ext)",0
000924  1  54 29 00     
000927  1  51 28 55 49  done2:            .byte "q(uit)",0
00092B  1  54 29 00     
00092E  1               
00092E  1               ; variables that the program uses during execution
00092E  1  00           currentlevel:   .byte 0 ; will need to be filled somewhere in the future in the GUI, or asked from the user
00092F  1  00           no_levels:      .byte 0 ; will be read by initfield
000930  1  00           no_goals:       .byte 0 ; will be read by initfield, depending on the currentlevel
000931  1  00           no_goalsreached:.byte 0 ; static now, reset for each game
000932  1  00           fieldwidth:     .byte 0 ; will be read by initfield, depending on the currentlevel
000933  1  00           fieldheight:    .byte 0 ; will be read by initfield, depending on the currentlevel
000934  1  00           vera_byte_low:  .byte 0
000935  1  00           vera_byte_mid:  .byte 0
000936  1  00 00 00 00  undostack:      .byte 0,0,0,0,0,0,0,0,0,0
00093A  1  00 00 00 00  
00093E  1  00 00        
000940  1  00           undoindex:      .byte 0
000941  1  00           undocounter:    .byte 0
000942  1               
000942  1               ; usage of zeropage address space:
000942  1               ; ZP_PTR_1 - temporary pointer
000942  1               ; ZP_PTR_2 - temporary pointer
000942  1               ; ZP_PTR_3 - position of player
000942  1               ZP_PTR_FIELD = $2A
000942  1               temp = $30  ; used for temp 8/16 bit storage $30/$31
000942  1               ZP_PTR_UNDO = $32 ; used to point to the 'undo stack'
000942  1               
000942  1               start:
000942  1                   ; force uppercase
000942  1  A9 8E            lda #UPPERCASE
000944  1  20 D2 FF         jsr CHROUT
000947  1               
000947  1  20 BA 0F         jsr loadtiles       ; load tiles from normal memory to VRAM
00094A  1  20 4E 11         jsr layerconfig     ; configure layer 0/1 on screen
00094D  1               
00094D  1  20 B4 0F         jsr cls
000950  1               
000950  1  20 3E 0E         jsr resetvars
000953  1  20 1D 11         jsr cleartiles
000956  1               
000956  1  20 89 10         jsr displaytitlescreen
000959  1  20 C2 0D         jsr selectlevel
00095C  1  90 04            bcc @continue
00095E  1  20 42 11         jsr resetlayerconfig
000961  1  60               rts                 ; pressed 'q'
000962  1               @continue:
000962  1  20 1D 11         jsr cleartiles      ; cls tiles
000965  1               
000965  1  20 81 0E         jsr initfield       ; load correct startup values for selected field
000968  1  20 96 11         jsr printfield2
00096B  1               
00096B  1               keyloop:
00096B  1  20 E4 FF         jsr GETIN
00096E  1               @checkdown:
00096E  1  C9 11            cmp #$11
000970  1  D0 05            bne @checkup
000972  1  20 EC 0B         jsr handledown
000975  1  80 61            bra @done
000977  1               @checkup:
000977  1  C9 91            cmp #$91
000979  1  D0 05            bne @checkleft
00097B  1  20 86 0B         jsr handleup
00097E  1  80 58            bra @done
000980  1               @checkleft:
000980  1  C9 9D            cmp #$9d
000982  1  D0 05            bne @checkright
000984  1  20 2D 0B         jsr handleleft
000987  1  80 4F            bra @done
000989  1               @checkright:
000989  1  C9 1D            cmp #$1d
00098B  1  D0 05            bne @checkundo
00098D  1  20 D4 0A         jsr handleright
000990  1  80 46            bra @done
000992  1               @checkundo:
000992  1  C9 55            cmp #$55 ; 'u'
000994  1  D0 05            bne @checkreset
000996  1  20 0F 0A         jsr handle_undocommand
000999  1  80 3D            bra @done
00099B  1               @checkreset:
00099B  1  C9 52            cmp #$52 ; 'r'
00099D  1  D0 21            bne @checkquit
00099F  1  20 BA 0A         jsr askreset
0009A2  1  B0 0B            bcs @resetgame
0009A4  1  20 B4 0F         jsr cls
0009A7  1  20 1D 11         jsr cleartiles
0009AA  1  20 96 11         jsr printfield2
0009AD  1  80 29            bra @done
0009AF  1               @resetgame:
0009AF  1  20 B4 0F         jsr cls
0009B2  1  20 1D 11         jsr cleartiles
0009B5  1  20 3E 0E         jsr resetvars
0009B8  1  20 81 0E         jsr initfield
0009BB  1  20 96 11         jsr printfield2
0009BE  1  80 AB            bra keyloop
0009C0  1               @checkquit:
0009C0  1  C9 51            cmp #$51 ; 'q'
0009C2  1  D0 14            bne @done
0009C4  1  20 A0 0A         jsr askquit
0009C7  1  B0 0B            bcs @exit
0009C9  1  20 B4 0F         jsr cls
0009CC  1  20 1D 11         jsr cleartiles
0009CF  1  20 96 11         jsr printfield2
0009D2  1  80 04            bra @done
0009D4  1               @exit:
0009D4  1  20 42 11         jsr resetlayerconfig
0009D7  1  60               rts
0009D8  1               @done:
0009D8  1                   ; check if we have reached all goals
0009D8  1  AD 30 09         lda no_goals
0009DB  1  CD 31 09         cmp no_goalsreached
0009DE  1  D0 2C            bne @donenextkey
0009E0  1  20 37 0A         jsr asknewlevel
0009E3  1  C9 4D            cmp #$4d ; Menu
0009E5  1  F0 08            beq @gotomenu   ; reset game / let user decide on new level
0009E7  1  C9 51            cmp #$51 ; Quit
0009E9  1  D0 07            bne @nextgame
0009EB  1  20 42 11         jsr resetlayerconfig
0009EE  1  60               rts
0009EF  1               @gotomenu:
0009EF  1  4C 42 09         jmp start
0009F2  1               @nextgame:
0009F2  1                   ; check if this was the last level
0009F2  1  AD 2F 09         lda no_levels
0009F5  1  CD 2E 09         cmp currentlevel
0009F8  1  F0 F5            beq @gotomenu   ; select another game
0009FA  1  EE 2E 09         inc currentlevel ; next level
0009FD  1  20 B4 0F         jsr cls
000A00  1  20 3E 0E         jsr resetvars
000A03  1  20 1D 11         jsr cleartiles
000A06  1               
000A06  1  20 81 0E         jsr initfield       ; load correct startup values for selected field
000A09  1  20 96 11         jsr printfield2
000A0C  1               
000A0C  1               @donenextkey:
000A0C  1  4C 6B 09         jmp keyloop
000A0F  1               
000A0F  1               handle_undocommand:
000A0F  1  20 BD 0C         jsr pull_undostack
000A12  1                   ; x now contains previous move
000A12  1                   ;   as #%000MUDRL - Multiple move / Up / Down / Right / Left
000A12  1                   ; we will give x to the handle_undo_**** routine, so it can see the combined bit (4) and act on it
000A12  1               @checkup:
000A12  1  8A               txa
000A13  1  29 08            and #%00001000
000A15  1  F0 04            beq @checkdown
000A17  1  20 B1 0B         jsr handle_undo_up
000A1A  1  60               rts
000A1B  1               @checkdown:
000A1B  1  8A               txa
000A1C  1  29 04            and #%00000100
000A1E  1  F0 04            beq @checkright
000A20  1  20 17 0C         jsr handle_undo_down
000A23  1  60               rts
000A24  1               @checkright:
000A24  1  8A               txa
000A25  1  29 02            and #%00000010
000A27  1  F0 04            beq @checkleft
000A29  1  20 F4 0A         jsr handle_undo_right
000A2C  1  60               rts
000A2D  1               @checkleft:
000A2D  1  8A               txa
000A2E  1  29 01            and #%00000001
000A30  1  F0 04            beq @emptystack
000A32  1  20 4D 0B         jsr handle_undo_left
000A35  1  60               rts
000A36  1               @emptystack:
000A36  1                   ; do nothing
000A36  1  60               rts
000A37  1               
000A37  1               asknewlevel:
000A37  1                   ; display level complete tilesetj
000A37  1  20 B4 0F         jsr cls
000A3A  1  A9 96            lda #<completescreen
000A3C  1  85 22            sta ZP_PTR_1
000A3E  1  A9 32            lda #>completescreen
000A40  1  85 23            sta ZP_PTR_1+1
000A42  1  20 53 10         jsr displaytileset
000A45  1               
000A45  1  9C 25 9F         stz VERA_CTRL
000A48  1  A2 09            ldx #$9 ; color brown
000A4A  1  A9 11            lda #$11
000A4C  1  8D 22 9F         sta VERA_HIGH
000A4F  1               
000A4F  1  A9 19            lda #<done0
000A51  1  85 22            sta ZP_PTR_1
000A53  1  A9 09            lda #>done0
000A55  1  85 23            sta ZP_PTR_1+1
000A57  1  A9 D5            lda #213 ; line 37
000A59  1  8D 21 9F         sta VERA_MID
000A5C  1  A9 4C            lda #38*2
000A5E  1  8D 20 9F         sta VERA_LOW
000A61  1  20 3C 10         jsr printverastring
000A64  1               
000A64  1  A9 20            lda #<done1
000A66  1  85 22            sta ZP_PTR_1
000A68  1  A9 09            lda #>done1
000A6A  1  85 23            sta ZP_PTR_1+1
000A6C  1  A9 D9            lda #217     ; line 41
000A6E  1  8D 21 9F         sta VERA_MID
000A71  1  A9 4C            lda #38*2
000A73  1  8D 20 9F         sta VERA_LOW
000A76  1  20 3C 10         jsr printverastring
000A79  1               
000A79  1  A9 27            lda #<done2
000A7B  1  85 22            sta ZP_PTR_1
000A7D  1  A9 09            lda #>done2
000A7F  1  85 23            sta ZP_PTR_1+1
000A81  1  A9 DD            lda #221     ; line 45
000A83  1  8D 21 9F         sta VERA_MID
000A86  1  A9 4C            lda #38*2
000A88  1  8D 20 9F         sta VERA_LOW
000A8B  1  20 3C 10         jsr printverastring
000A8E  1               
000A8E  1               @keyloop:
000A8E  1  20 E4 FF         jsr GETIN
000A91  1               @checkmenu:
000A91  1  C9 4D            cmp #$4D ; M (enu)
000A93  1  D0 01            bne @checknext
000A95  1  60               rts
000A96  1               @checknext:
000A96  1  C9 4E            cmp #$4E ; N (ext)
000A98  1  D0 01            bne @checkquit
000A9A  1  60               rts
000A9B  1               @checkquit:
000A9B  1  C9 51            cmp #$51 ; Q (uit)
000A9D  1  D0 EF            bne @keyloop
000A9F  1  60               rts
000AA0  1               
000AA0  1               askquit:
000AA0  1                   ; ask if the user would like to quit, and return carry on 'y'
000AA0  1  A9 10            lda #<quitaskmessage
000AA2  1  85 22            sta ZP_PTR_1
000AA4  1  A9 08            lda #>quitaskmessage
000AA6  1  85 23            sta ZP_PTR_1+1
000AA8  1  20 0D 10         jsr displaymessagescreen
000AAB  1               
000AAB  1               @keyloop:
000AAB  1  20 E4 FF         jsr GETIN
000AAE  1               @checkyes:
000AAE  1  C9 59            cmp #$59 ; Y
000AB0  1  D0 02            bne @checkno
000AB2  1  38               sec
000AB3  1  60               rts
000AB4  1               @checkno:
000AB4  1  C9 4E            cmp #$4e ; N
000AB6  1  D0 F3            bne @keyloop
000AB8  1  18               clc
000AB9  1  60               rts
000ABA  1               
000ABA  1               askreset:
000ABA  1                   ; ask if the user would like to reset, and return carry on 'y'
000ABA  1  A9 61            lda #<resetmessage
000ABC  1  85 22            sta ZP_PTR_1
000ABE  1  A9 08            lda #>resetmessage
000AC0  1  85 23            sta ZP_PTR_1+1
000AC2  1  20 0D 10         jsr displaymessagescreen
000AC5  1               
000AC5  1               @keyloop:
000AC5  1  20 E4 FF         jsr GETIN
000AC8  1               @checkyes:
000AC8  1  C9 59            cmp #$59 ; Y
000ACA  1  D0 02            bne @checkno
000ACC  1  38               sec
000ACD  1  60               rts
000ACE  1               @checkno:
000ACE  1  C9 4E            cmp #$4e ; N
000AD0  1  D0 F3            bne @keyloop
000AD2  1  18               clc
000AD3  1  60               rts
000AD4  1               
000AD4  1               handleright:
000AD4  1                   ; pointers
000AD4  1                   ; 3 - player
000AD4  1                   ; 2 - block to the right of the player
000AD4  1                   ; 1 - block to the right of that block
000AD4  1               
000AD4  1                   ; ZP_PTR_2 = ZP_PTR_3 + 1x position
000AD4  1  18               clc
000AD5  1  A5 26            lda ZP_PTR_3
000AD7  1  69 01            adc #$1               ; 1x position
000AD9  1  85 24            sta ZP_PTR_2
000ADB  1  A5 27            lda ZP_PTR_3+1
000ADD  1  69 00            adc #$0
000ADF  1  85 25            sta ZP_PTR_2+1
000AE1  1               
000AE1  1                   ; ZP_PTR_1 = ZP_PTR_1 + 2x position
000AE1  1  18               clc
000AE2  1  A5 26            lda ZP_PTR_3
000AE4  1  69 02            adc #$2               ; 2x position
000AE6  1  85 22            sta ZP_PTR_1
000AE8  1  A5 27            lda ZP_PTR_3+1
000AEA  1  69 00            adc #$0
000AEC  1  85 23            sta ZP_PTR_1+1
000AEE  1               
000AEE  1  A2 02            ldx #%00000010 ; right direction
000AF0  1  20 52 0C         jsr handlemove
000AF3  1  60               rts
000AF4  1               
000AF4  1               handle_undo_right:
000AF4  1                   ; 3 - player
000AF4  1               
000AF4  1  DA               phx ; store x to stack
000AF5  1                   ; point 1 to player
000AF5  1               
000AF5  1  A5 26            lda ZP_PTR_3
000AF7  1  85 22            sta ZP_PTR_1
000AF9  1  A5 27            lda ZP_PTR_3+1
000AFB  1  85 23            sta ZP_PTR_1+1
000AFD  1               
000AFD  1                   ; pointer 2 will point to the left of the player
000AFD  1                   ; so the player will move back to the left
000AFD  1  38               sec
000AFE  1  A5 26            lda ZP_PTR_3
000B00  1  E9 01            sbc #$1
000B02  1  85 24            sta ZP_PTR_2
000B04  1  A5 27            lda ZP_PTR_3+1
000B06  1  E9 00            sbc #$0
000B08  1  85 25            sta ZP_PTR_2+1
000B0A  1               
000B0A  1  20 25 0D         jsr moveplayeronfield
000B0D  1  20 DB 0C         jsr moveplayerposition
000B10  1               
000B10  1                   ; check crate move, and if so, move it using pointer 2 -> 1
000B10  1  FA               plx
000B11  1  8A               txa
000B12  1  29 10            and #%00010000 ; was a crate moved in this move?
000B14  1  F0 10            beq @done
000B16  1               
000B16  1                   ; load pointer 2 to the right of the previous player's position
000B16  1  18               clc
000B17  1  A5 22            lda ZP_PTR_1
000B19  1  69 01            adc #$1
000B1B  1  85 24            sta ZP_PTR_2
000B1D  1  A5 23            lda ZP_PTR_1+1
000B1F  1  69 00            adc #$0
000B21  1  85 25            sta ZP_PTR_2+1
000B23  1               
000B23  1  20 E4 0C         jsr movecrateonfield
000B26  1               @done:
000B26  1  20 B4 0F         jsr cls
000B29  1  20 96 11         jsr printfield2
000B2C  1  60               rts
000B2D  1               
000B2D  1               handleleft:
000B2D  1                   ; pointers
000B2D  1                   ; 3 - player
000B2D  1                   ; 2 - block to the left of the player
000B2D  1                   ; 1 - block to the left of that block
000B2D  1               
000B2D  1                   ; ZP_PTR_2 = ZP_PTR_3 - 1x position
000B2D  1  38               sec
000B2E  1  A5 26            lda ZP_PTR_3
000B30  1  E9 01            sbc #$1               ; 1x position
000B32  1  85 24            sta ZP_PTR_2
000B34  1  A5 27            lda ZP_PTR_3+1
000B36  1  E9 00            sbc #$0
000B38  1  85 25            sta ZP_PTR_2+1
000B3A  1               
000B3A  1                   ; ZP_PTR_1 = ZP_PTR_1 - 2x position
000B3A  1  38               sec
000B3B  1  A5 26            lda ZP_PTR_3
000B3D  1  E9 02            sbc #$2               ; 2x position
000B3F  1  85 22            sta ZP_PTR_1
000B41  1  A5 27            lda ZP_PTR_3+1
000B43  1  E9 00            sbc #$0
000B45  1  85 23            sta ZP_PTR_1+1
000B47  1               
000B47  1  A2 01            ldx #%00000001 ; left direction
000B49  1  20 52 0C         jsr handlemove
000B4C  1               
000B4C  1               @done:
000B4C  1  60               rts
000B4D  1               
000B4D  1               handle_undo_left:
000B4D  1                   ; 3 - player
000B4D  1               
000B4D  1  DA               phx ; store x to stack
000B4E  1               
000B4E  1                   ; point 1 to player
000B4E  1  A5 26            lda ZP_PTR_3
000B50  1  85 22            sta ZP_PTR_1
000B52  1  A5 27            lda ZP_PTR_3+1
000B54  1  85 23            sta ZP_PTR_1+1
000B56  1               
000B56  1                   ; pointer 2 will point to the right of the player
000B56  1                   ; so the player will move back to the right
000B56  1  18               clc
000B57  1  A5 26            lda ZP_PTR_3
000B59  1  69 01            adc #$1
000B5B  1  85 24            sta ZP_PTR_2
000B5D  1  A5 27            lda ZP_PTR_3+1
000B5F  1  69 00            adc #$0
000B61  1  85 25            sta ZP_PTR_2+1
000B63  1               
000B63  1  20 25 0D         jsr moveplayeronfield
000B66  1  20 DB 0C         jsr moveplayerposition
000B69  1               
000B69  1                   ; check crate move, and if so, move it using pointer 2 -> 1
000B69  1  FA               plx
000B6A  1  8A               txa
000B6B  1  29 10            and #%00010000 ; was a crate moved in this move?
000B6D  1  F0 10            beq @done
000B6F  1               
000B6F  1                   ; load pointer 2 to the left of the previous player's position
000B6F  1  38               sec
000B70  1  A5 22            lda ZP_PTR_1
000B72  1  E9 01            sbc #$1
000B74  1  85 24            sta ZP_PTR_2
000B76  1  A5 23            lda ZP_PTR_1+1
000B78  1  E9 00            sbc #$0
000B7A  1  85 25            sta ZP_PTR_2+1
000B7C  1               
000B7C  1  20 E4 0C         jsr movecrateonfield
000B7F  1               @done:
000B7F  1  20 B4 0F         jsr cls
000B82  1  20 96 11         jsr printfield2
000B85  1  60               rts
000B86  1               
000B86  1               handleup:
000B86  1                   ; pointers
000B86  1                   ; 3 - player
000B86  1                   ; 2 - block to the top of the player
000B86  1                   ; 1 - block to the top of that block
000B86  1               
000B86  1                   ; ZP_PTR_2 = ZP_PTR_3 - 1xFIELDWIDTH
000B86  1  AD 32 09         lda fieldwidth
000B89  1  85 30            sta temp
000B8B  1  38               sec
000B8C  1  A5 26            lda ZP_PTR_3
000B8E  1  E5 30            sbc temp
000B90  1  85 24            sta ZP_PTR_2
000B92  1  A5 27            lda ZP_PTR_3+1
000B94  1  E9 00            sbc #$0
000B96  1  85 25            sta ZP_PTR_2+1
000B98  1               
000B98  1                   ; ZP_PTR_1 = ZP_PTR_1 - 2xFIELDWIDTH
000B98  1  AD 32 09         lda fieldwidth
000B9B  1  0A               asl ; 2x
000B9C  1  85 30            sta temp
000B9E  1  38               sec
000B9F  1  A5 26            lda ZP_PTR_3
000BA1  1  E5 30            sbc temp
000BA3  1  85 22            sta ZP_PTR_1
000BA5  1  A5 27            lda ZP_PTR_3+1
000BA7  1  E9 00            sbc #$0
000BA9  1  85 23            sta ZP_PTR_1+1
000BAB  1               
000BAB  1  A2 08            ldx #%00001000 ; up direction
000BAD  1  20 52 0C         jsr handlemove
000BB0  1               
000BB0  1  60               rts
000BB1  1               
000BB1  1               handle_undo_up:
000BB1  1                   ; 3 - player
000BB1  1               
000BB1  1  DA               phx ; store x to stack
000BB2  1               
000BB2  1                   ; point 1 to player
000BB2  1  A5 26            lda ZP_PTR_3
000BB4  1  85 22            sta ZP_PTR_1
000BB6  1  A5 27            lda ZP_PTR_3+1
000BB8  1  85 23            sta ZP_PTR_1+1
000BBA  1               
000BBA  1                   ; pointer 2 will point to the position down of the player
000BBA  1                   ; so the player will move back down
000BBA  1  18               clc
000BBB  1  A5 26            lda ZP_PTR_3
000BBD  1  6D 32 09         adc fieldwidth
000BC0  1  85 24            sta ZP_PTR_2
000BC2  1  A5 27            lda ZP_PTR_3+1
000BC4  1  69 00            adc #$0
000BC6  1  85 25            sta ZP_PTR_2+1
000BC8  1               
000BC8  1  20 25 0D         jsr moveplayeronfield
000BCB  1  20 DB 0C         jsr moveplayerposition
000BCE  1               
000BCE  1                   ; check crate move, and if so, move it using pointer 2 -> 1
000BCE  1  FA               plx
000BCF  1  8A               txa
000BD0  1  29 10            and #%00010000 ; was a crate moved in this move?
000BD2  1  F0 11            beq @done
000BD4  1               
000BD4  1                   ; load pointer 2 to the top of the previous player's position
000BD4  1  38               sec
000BD5  1  A5 22            lda ZP_PTR_1
000BD7  1  ED 32 09         sbc fieldwidth
000BDA  1  85 24            sta ZP_PTR_2
000BDC  1  A5 23            lda ZP_PTR_1+1
000BDE  1  E9 00            sbc #$0
000BE0  1  85 25            sta ZP_PTR_2+1
000BE2  1               
000BE2  1  20 E4 0C         jsr movecrateonfield
000BE5  1               @done:
000BE5  1  20 B4 0F         jsr cls
000BE8  1  20 96 11         jsr printfield2
000BEB  1  60               rts
000BEC  1               
000BEC  1               handledown:
000BEC  1                   ; pointers
000BEC  1                   ; 3 - player
000BEC  1                   ; 2 - block to the bottom of the player
000BEC  1                   ; 1 - block to the bottom of that block
000BEC  1               
000BEC  1                   ; ZP_PTR_2 = ZP_PTR_3 + 1xFIELDWIDTH
000BEC  1  AD 32 09         lda fieldwidth
000BEF  1  85 30            sta temp
000BF1  1  18               clc
000BF2  1  A5 26            lda ZP_PTR_3
000BF4  1  65 30            adc temp
000BF6  1  85 24            sta ZP_PTR_2
000BF8  1  A5 27            lda ZP_PTR_3+1
000BFA  1  69 00            adc #$0
000BFC  1  85 25            sta ZP_PTR_2+1
000BFE  1               
000BFE  1                   ; ZP_PTR_1 = ZP_PTR_1 + 2xFIELDWIDTH
000BFE  1  AD 32 09         lda fieldwidth
000C01  1  0A               asl ; 2x
000C02  1  85 30            sta temp
000C04  1  18               clc
000C05  1  A5 26            lda ZP_PTR_3
000C07  1  65 30            adc temp
000C09  1  85 22            sta ZP_PTR_1
000C0B  1  A5 27            lda ZP_PTR_3+1
000C0D  1  69 00            adc #$0
000C0F  1  85 23            sta ZP_PTR_1+1
000C11  1               
000C11  1  A2 04            ldx #%00000100 ; down direction
000C13  1  20 52 0C         jsr handlemove
000C16  1               
000C16  1  60               rts
000C17  1               
000C17  1               handle_undo_down:
000C17  1                   ; 3 - player
000C17  1               
000C17  1  DA               phx ; store x to stack
000C18  1               
000C18  1                   ; point 1 to player
000C18  1  A5 26            lda ZP_PTR_3
000C1A  1  85 22            sta ZP_PTR_1
000C1C  1  A5 27            lda ZP_PTR_3+1
000C1E  1  85 23            sta ZP_PTR_1+1
000C20  1               
000C20  1                   ; pointer 2 will point to the position up of the player
000C20  1                   ; so the player will move back up
000C20  1  38               sec
000C21  1  A5 26            lda ZP_PTR_3
000C23  1  ED 32 09         sbc fieldwidth
000C26  1  85 24            sta ZP_PTR_2
000C28  1  A5 27            lda ZP_PTR_3+1
000C2A  1  E9 00            sbc #$0
000C2C  1  85 25            sta ZP_PTR_2+1
000C2E  1               
000C2E  1  20 25 0D         jsr moveplayeronfield
000C31  1  20 DB 0C         jsr moveplayerposition
000C34  1               
000C34  1                   ; check crate move, and if so, move it using pointer 2 -> 1
000C34  1  FA               plx
000C35  1  8A               txa
000C36  1  29 10            and #%00010000 ; was a crate moved in this move?
000C38  1  F0 11            beq @done
000C3A  1               
000C3A  1                   ; load pointer 2 to the bottom of the previous player's position
000C3A  1  18               clc
000C3B  1  A5 22            lda ZP_PTR_1
000C3D  1  6D 32 09         adc fieldwidth
000C40  1  85 24            sta ZP_PTR_2
000C42  1  A5 23            lda ZP_PTR_1+1
000C44  1  69 00            adc #$0
000C46  1  85 25            sta ZP_PTR_2+1
000C48  1               
000C48  1  20 E4 0C         jsr movecrateonfield
000C4B  1               @done:
000C4B  1  20 B4 0F         jsr cls
000C4E  1  20 96 11         jsr printfield2
000C51  1  60               rts
000C52  1               
000C52  1               handlemove:
000C52  1                   ; pointers
000C52  1                   ; 3 - points to the player position
000C52  1                   ; 2 - points to the next block at the indicated direction
000C52  1                   ; 1 - points to the block after that block
000C52  1               
000C52  1  DA               phx ; push x to stack with stored direction
000C53  1               
000C53  1  A0 00            ldy #0
000C55  1  B1 24            lda (ZP_PTR_2),y
000C57  1  C9 20            cmp #' ' ; empty block next to player?
000C59  1  F0 06            beq @moveplayertopoint2
000C5B  1  C9 2E            cmp #'.' ; goal position next to player?
000C5D  1  F0 02            beq @moveplayertopoint2
000C5F  1  80 0C            bra @next ; no ' ' or '.' found next to player, is it a crate or a wall?
000C61  1               @moveplayertopoint2:
000C61  1                   ; move player to pointer 2
000C61  1  20 25 0D         jsr moveplayeronfield
000C64  1  20 DB 0C         jsr moveplayerposition
000C67  1               
000C67  1  FA               plx ; pull direction from the stack
000C68  1  20 A0 0C         jsr push_undostack
000C6B  1  80 2A            bra @movecomplete
000C6D  1               @next:
000C6D  1  A0 00            ldy #0
000C6F  1  B1 24            lda (ZP_PTR_2),y
000C71  1  C9 24            cmp #'$' ; crate next to player?
000C73  1  F0 06            beq @combinedmovecheck
000C75  1  C9 2A            cmp #'*' ; crate on goal next to player?
000C77  1  F0 02            beq @combinedmovecheck
000C79  1  80 23            bra @ignore ; something else not able to push
000C7B  1               @combinedmovecheck:
000C7B  1  B1 22            lda (ZP_PTR_1),y
000C7D  1  C9 20            cmp #' ' ; space after crate?
000C7F  1  F0 06            beq @combinedmove
000C81  1  C9 2E            cmp #'.' ; goal after crate?
000C83  1  F0 02            beq @combinedmove
000C85  1  80 17            bra @ignore ; nothing to move
000C87  1               @combinedmove:
000C87  1  20 E4 0C         jsr movecrateonfield
000C8A  1  20 25 0D         jsr moveplayeronfield
000C8D  1  20 DB 0C         jsr moveplayerposition
000C90  1               
000C90  1                   ; record combined move to undo stack
000C90  1  68               pla
000C91  1  09 10            ora #%00010000   ; set 'combined' bit 4
000C93  1  AA               tax
000C94  1  20 A0 0C         jsr push_undostack
000C97  1               
000C97  1               @movecomplete:
000C97  1  20 96 11         jsr printfield2
000C9A  1  20 B4 0F         jsr cls
000C9D  1  60               rts
000C9E  1               
000C9E  1               @ignore: ; nothing to move
000C9E  1  FA               plx  ; don't forget to remove the stacked x move
000C9F  1  60               rts
000CA0  1               
000CA0  1               push_undostack:
000CA0  1                   ; record single move to undo stack
000CA0  1                   ; x contains direction and single/multiple move
000CA0  1                   ; x = 0%000MUDRL - Multiple / Up / Down / Right / Left
000CA0  1                   ;
000CA0  1                   ; the stack index 'pointer' undoindex points to a new entry each time
000CA0  1  8A               txa
000CA1  1  AC 40 09         ldy undoindex
000CA4  1  91 32            sta (ZP_PTR_UNDO),y
000CA6  1               
000CA6  1  C0 09            cpy #MAXUNDO-1 ; at last physical item in memory? then loop around
000CA8  1  F0 05            beq @loopindex
000CAA  1  EE 40 09         inc undoindex
000CAD  1  80 03            bra @checkmaxcount
000CAF  1                @loopindex:
000CAF  1  9C 40 09         stz undoindex
000CB2  1                @checkmaxcount:
000CB2  1  AD 41 09         lda undocounter
000CB5  1  C9 0A            cmp #MAXUNDO
000CB7  1  F0 03            beq @done ; maximum count reached / stack will loop around
000CB9  1  EE 41 09         inc undocounter
000CBC  1                @done:
000CBC  1  60               rts
000CBD  1               
000CBD  1               pull_undostack:
000CBD  1                   ; remove single move from undo stack
000CBD  1                   ; afterwards, x contains direction and single/multiple move
000CBD  1                   ; x = 0%000MUDRL - Multiple / Up / Down / Right / Left
000CBD  1               
000CBD  1  AD 41 09         lda undocounter ; check if we have any moves pushed to the stack
000CC0  1  D0 03            bne @stackedmoves
000CC2  1  A2 00            ldx #$0 ; empty move, nothing in the stack
000CC4  1  60               rts
000CC5  1               
000CC5  1               @stackedmoves:
000CC5  1  CE 41 09         dec undocounter ; reduce the number pushed to the stack with 1
000CC8  1  AC 40 09         ldy undoindex
000CCB  1  C0 00            cpy #$0 ; index at first position?
000CCD  1  D0 04            bne @normalindex
000CCF  1  A0 09            ldy #MAXUNDO-1 ; move it to the 'previous' index position in a circular manner
000CD1  1  80 01            bra @next
000CD3  1               @normalindex:
000CD3  1  88               dey ; move it to the 'previous' index position
000CD4  1               @next:
000CD4  1  8C 40 09         sty undoindex
000CD7  1                   ; y now points to the previous move, as an index to the stack memory
000CD7  1  B1 32            lda (ZP_PTR_UNDO),y
000CD9  1  AA               tax
000CDA  1  60               rts
000CDB  1               
000CDB  1               moveplayerposition:
000CDB  1                   ; moves pointer 3 to position of pointer 2
000CDB  1  A5 24            lda ZP_PTR_2
000CDD  1  85 26            sta ZP_PTR_3
000CDF  1  A5 25            lda ZP_PTR_2+1
000CE1  1  85 27            sta ZP_PTR_3+1
000CE3  1  60               rts
000CE4  1               
000CE4  1               movecrateonfield:
000CE4  1                   ; copies (ZP_PTR_2) to (ZP_PTR_1)
000CE4  1                   ; and handles different crate move options (normal / crate on goal)
000CE4  1  A0 00            ldy #0
000CE6  1  B1 24            lda (ZP_PTR_2),y
000CE8  1                   ; was there a goal underneath the crate?
000CE8  1  C9 2A            cmp #'*'
000CEA  1  D0 1D            bne @crateonly
000CEC  1                   ; do we move to a goal position? (from goal to goal..)
000CEC  1  B1 22            lda (ZP_PTR_1),y
000CEE  1  C9 2E            cmp #'.'
000CF0  1  D0 0A            bne @movetonormalposition
000CF2  1               @movetogoalposition:
000CF2  1  A9 2A            lda #'*' ; crate on goal symbol
000CF4  1  91 22            sta (ZP_PTR_1),y
000CF6  1  A9 2E            lda #'.'
000CF8  1  91 24            sta (ZP_PTR_2),y
000CFA  1  80 28            bra @done
000CFC  1               @movetonormalposition:
000CFC  1  CE 31 09         dec no_goalsreached ; -1 win points
000CFF  1  A9 24            lda #'$'; crate symbol
000D01  1  91 22            sta (ZP_PTR_1),y
000D03  1  A9 2E            lda #'.'
000D05  1  91 24            sta (ZP_PTR_2),y
000D07  1  80 1B            bra @done
000D09  1               @crateonly:
000D09  1                   ; is the destination a goal?
000D09  1  B1 22            lda (ZP_PTR_1),y
000D0B  1  C9 2E            cmp #'.'
000D0D  1  D0 0D            bne @crateonly_nongoal
000D0F  1                   ; crate moves to goal, from a non-goal position
000D0F  1  EE 31 09         inc no_goalsreached ; +1 to win
000D12  1  A9 2A            lda #'*'
000D14  1  91 22            sta (ZP_PTR_1),y
000D16  1  A9 20            lda #' '
000D18  1  91 24            sta (ZP_PTR_2),y
000D1A  1  80 08            bra @done
000D1C  1               @crateonly_nongoal:
000D1C  1  A9 24            lda #'$'
000D1E  1  91 22            sta (ZP_PTR_1),y
000D20  1  A9 20            lda #' '; empty space to move the player in next
000D22  1  91 24            sta (ZP_PTR_2),y
000D24  1               @done:
000D24  1  60               rts
000D25  1               
000D25  1               moveplayeronfield:
000D25  1                   ; copies (ZP_PTR_3) to (ZP_PTR_2)
000D25  1                   ; and handles multiple player move options (normal / on goal)
000D25  1  A0 00            ldy #0
000D27  1  B1 26            lda (ZP_PTR_3),y
000D29  1                   ; was there a goal underneath the player?
000D29  1  C9 2B            cmp #'+'
000D2B  1  D0 1A            bne @playeronly
000D2D  1                   ; do we move to a goal position? (from goal to goal..)
000D2D  1  B1 24            lda (ZP_PTR_2),y
000D2F  1  C9 2E            cmp #'.'
000D31  1  D0 0A            bne @movetonormalposition
000D33  1               @movetogoalposition:
000D33  1  A9 2B            lda #'+' ; player on goal symbol
000D35  1  91 24            sta (ZP_PTR_2),y
000D37  1  A9 2E            lda #'.'
000D39  1  91 26            sta (ZP_PTR_3),y
000D3B  1  80 22            bra @done
000D3D  1               @movetonormalposition:
000D3D  1  A9 40            lda #'@'; player symbol
000D3F  1  91 24            sta (ZP_PTR_2),y
000D41  1  A9 2E            lda #'.'
000D43  1  91 26            sta (ZP_PTR_3),y
000D45  1  80 18            bra @done
000D47  1               @playeronly:
000D47  1                   ; is the destination a goal?
000D47  1  B1 24            lda (ZP_PTR_2),y
000D49  1  C9 2E            cmp #'.'
000D4B  1  D0 0A            bne @playeronly_nongoal
000D4D  1                   ; player moves to goal, from a non-goal position
000D4D  1  A9 2B            lda #'+'
000D4F  1  91 24            sta (ZP_PTR_2),y
000D51  1  A9 20            lda #' '
000D53  1  91 26            sta (ZP_PTR_3),y
000D55  1  80 08            bra @done
000D57  1               @playeronly_nongoal:
000D57  1  A9 40            lda #'@'
000D59  1  91 24            sta (ZP_PTR_2),y
000D5B  1  A9 20            lda #' '; empty space
000D5D  1  91 26            sta (ZP_PTR_3),y
000D5F  1               @done:
000D5F  1  60               rts
000D60  1               
000D60  1               print:
000D60  1                   ; console routines only
000D60  1                   ; print from address ZP_PTR_1
000D60  1                   ; don't end with newline character
000D60  1  5A               phy
000D61  1  A0 00            ldy #0
000D63  1               @loop:
000D63  1  B1 22            lda (ZP_PTR_1),y ; load character from address
000D65  1  F0 06            beq @done        ; end at 0 character
000D67  1  20 D2 FF         jsr CHROUT
000D6A  1  C8               iny
000D6B  1  80 F6            bra @loop
000D6D  1               @done:
000D6D  1  7A               ply
000D6E  1  60               rts
000D6F  1               
000D6F  1               printline:
000D6F  1                   ; console routines only
000D6F  1                   ; print from address ZP_PTR_1
000D6F  1                   ; end with newline character
000D6F  1  20 60 0D         jsr print
000D72  1  A9 0D            lda #NEWLINE
000D74  1  20 D2 FF         jsr CHROUT
000D77  1  60               rts
000D78  1               
000D78  1               printwinstatement:
000D78  1                   ; console routines only
000D78  1  A9 89            lda #<winstatement
000D7A  1  85 22            sta ZP_PTR_1
000D7C  1  A9 08            lda #>winstatement
000D7E  1  85 23            sta ZP_PTR_1+1
000D80  1  20 6F 0D         jsr printline
000D83  1  60               rts
000D84  1               
000D84  1               printdecimal:
000D84  1                   ; prints decimal from A register
000D84  1                   ; VERA control needs to be set up previously
000D84  1  DA               phx
000D85  1  5A               phy
000D86  1  86 30            stx temp    ; keep color to print in
000D88  1  A0 2F            ldy #$2f
000D8A  1  A2 3A            ldx #$3a
000D8C  1  38               sec
000D8D  1               @loop1:
000D8D  1  C8               iny
000D8E  1  E9 64            sbc #100
000D90  1  B0 FB            bcs @loop1
000D92  1               @loop2:
000D92  1  CA               dex
000D93  1  69 0A            adc #10
000D95  1  30 FB            bmi @loop2
000D97  1  69 2F            adc #$2f
000D99  1               
000D99  1                   ; Y = hundreds, X = tens, A = ones
000D99  1  48               pha
000D9A  1  8A               txa
000D9B  1  48               pha
000D9C  1  98               tya
000D9D  1  C9 30            cmp #$30 ; is it a '0' petscii?
000D9F  1  F0 08            beq @tens
000DA1  1  8D 23 9F         sta VERA_DATA0
000DA4  1  A5 30            lda temp
000DA6  1  8D 23 9F         sta VERA_DATA0
000DA9  1               @tens:
000DA9  1  68               pla
000DAA  1  C9 30            cmp #$30 ; is it a '0' petscii?
000DAC  1  F0 08            beq @ones
000DAE  1  8D 23 9F         sta VERA_DATA0
000DB1  1  A5 30            lda temp
000DB3  1  8D 23 9F         sta VERA_DATA0
000DB6  1               @ones:
000DB6  1  68               pla
000DB7  1  8D 23 9F         sta VERA_DATA0
000DBA  1  A5 30            lda temp
000DBC  1  8D 23 9F         sta VERA_DATA0
000DBF  1               
000DBF  1  7A               ply
000DC0  1  FA               plx
000DC1  1  60               rts
000DC2  1               
000DC2  1               selectlevel:
000DC2  1  A9 01            lda #1 ; start out with first level
000DC4  1  8D 2E 09         sta currentlevel
000DC7  1               
000DC7  1               @mainloop:
000DC7  1  20 61 0E         jsr clearselect
000DCA  1                   ; text prep to VERA
000DCA  1  9C 25 9F         stz VERA_CTRL
000DCD  1  A2 09            ldx #$9 ; color brown
000DCF  1  A9 11            lda #$11
000DD1  1  8D 22 9F         sta VERA_HIGH
000DD4  1  A9 21            lda #<selectmessage
000DD6  1  85 22            sta ZP_PTR_1
000DD8  1  A9 08            lda #>selectmessage
000DDA  1  85 23            sta ZP_PTR_1+1
000DDC  1  A9 DD            lda #221     ; line 45
000DDE  1  8D 21 9F         sta VERA_MID
000DE1  1  A9 14            lda #10*2
000DE3  1  8D 20 9F         sta VERA_LOW
000DE6  1  20 3C 10         jsr printverastring
000DE9  1               
000DE9  1                   ; print range
000DE9  1  AD 2F 09         lda no_levels
000DEC  1  20 84 0D         jsr printdecimal
000DEF  1  A9 34            lda #<selectendmessage
000DF1  1  85 22            sta ZP_PTR_1
000DF3  1  A9 08            lda #>selectendmessage
000DF5  1  85 23            sta ZP_PTR_1+1
000DF7  1  20 3C 10         jsr printverastring
000DFA  1                   ; print level number
000DFA  1  AD 2E 09         lda currentlevel
000DFD  1  20 84 0D         jsr printdecimal
000E00  1               
000E00  1               @charloop:
000E00  1  20 E4 FF         jsr GETIN
000E03  1               @checkdown:
000E03  1  C9 11            cmp #$11 ; down pressed
000E05  1  F0 06            beq @down
000E07  1  C9 9D            cmp #$9d ; left pressed
000E09  1  F0 02            beq @down
000E0B  1  80 0C            bra @checkup
000E0D  1               @down:
000E0D  1                   ; down key pressed
000E0D  1  AD 2E 09         lda currentlevel
000E10  1  C9 01            cmp #1
000E12  1  F0 EC            beq @charloop   ; lowest value == 1
000E14  1  CE 2E 09         dec currentlevel
000E17  1  80 AE            bra @mainloop
000E19  1               @checkup:
000E19  1  C9 91            cmp #$91 ; up pressed
000E1B  1  F0 06            beq @up
000E1D  1  C9 1D            cmp #$1d ; right pressed
000E1F  1  F0 02            beq @up
000E21  1  80 0D            bra @checkreturnkey
000E23  1               @up:
000E23  1                   ; up key pressed
000E23  1  AD 2E 09         lda currentlevel
000E26  1  CD 2F 09         cmp no_levels
000E29  1  F0 D5            beq @charloop   ; maximum value reached
000E2B  1  EE 2E 09         inc currentlevel
000E2E  1  80 97            bra @mainloop
000E30  1               @checkreturnkey:
000E30  1  C9 0D            cmp #$0d
000E32  1  D0 04            bne @checkquit
000E34  1                   ; return key pressed - select this level
000E34  1  20 B4 0F         jsr cls
000E37  1  60               rts
000E38  1               @checkquit:
000E38  1  C9 51            cmp #$51
000E3A  1  D0 C4            bne @charloop
000E3C  1  38               sec ; set carry to notify caller
000E3D  1  60               rts
000E3E  1               resetvars:
000E3E  1                   ; reset goals
000E3E  1  A9 00            lda #0
000E40  1  8D 31 09         sta no_goalsreached
000E43  1               
000E43  1                   ; load field pointer to first address at LOADSTART
000E43  1                   ; load 1st pointer to temp pointer ZP_PTR_1
000E43  1  A9 96            lda #<LOADSTART
000E45  1  85 22            sta ZP_PTR_1
000E47  1  A9 48            lda #>LOADSTART
000E49  1  85 23            sta ZP_PTR_1+1
000E4B  1               
000E4B  1                   ; load number of levels, pointed to by ZP_PTR_1,0
000E4B  1  A0 00            ldy #0
000E4D  1  B1 22            lda (ZP_PTR_1),y
000E4F  1  8D 2F 09         sta no_levels
000E52  1               
000E52  1                   ; reset undo stack
000E52  1  A9 36            lda #<undostack
000E54  1  85 32            sta ZP_PTR_UNDO
000E56  1  A9 09            lda #>undostack
000E58  1  85 33            sta ZP_PTR_UNDO+1
000E5A  1               
000E5A  1  9C 40 09         stz undoindex
000E5D  1  9C 41 09         stz undocounter
000E60  1  60               rts
000E61  1               
000E61  1               clearselect:
000E61  1                   ; clear out select text first
000E61  1  9C 25 9F         stz VERA_CTRL
000E64  1  A2 09            ldx #$9
000E66  1  A9 11            lda #$11
000E68  1  8D 22 9F         sta VERA_HIGH
000E6B  1  A9 38            lda #<clear
000E6D  1  85 22            sta ZP_PTR_1
000E6F  1  A9 08            lda #>clear
000E71  1  85 23            sta ZP_PTR_1+1
000E73  1  A9 DD            lda #221     ;line 45
000E75  1  8D 21 9F         sta VERA_MID
000E78  1  A9 14            lda #10*2
000E7A  1  8D 20 9F         sta VERA_LOW
000E7D  1  20 3C 10         jsr printverastring
000E80  1  60               rts
000E81  1               
000E81  1               initfield:
000E81  1                   ; load field pointer to first address at LOADSTART
000E81  1                   ; load 1st pointer to temp pointer ZP_PTR_1
000E81  1  A9 96            lda #<LOADSTART
000E83  1  85 22            sta ZP_PTR_1
000E85  1  A9 48            lda #>LOADSTART
000E87  1  85 23            sta ZP_PTR_1+1
000E89  1               
000E89  1                   ; skip to the first header, two bytes next
000E89  1  18               clc
000E8A  1  A5 22            lda ZP_PTR_1
000E8C  1  69 02            adc #2
000E8E  1  85 22            sta ZP_PTR_1
000E90  1               
000E90  1                   ; now advance pointer (currentlevel - 1) * HEADERSIZE to advance to the correct payload pointer to that level
000E90  1  AD 2E 09         lda currentlevel
000E93  1  AA               tax ; x contains the currentlevel now and will act as a counter
000E94  1               @loop:
000E94  1  CA               dex
000E95  1  F0 11            beq @fieldptrdone
000E97  1                   ; advance the field payload pointer
000E97  1  A5 22            lda ZP_PTR_1
000E99  1  18               clc
000E9A  1  69 0C            adc #LEVELHEADER
000E9C  1  85 22            sta ZP_PTR_1
000E9E  1  90 F4            bcc @loop   ; nothing to do for the high byte
000EA0  1  A5 23            lda ZP_PTR_1+1
000EA2  1  69 00            adc #$0     ; increase the high byte
000EA4  1  85 23            sta ZP_PTR_1+1
000EA6  1  80 EC            bra @loop
000EA8  1               @fieldptrdone:
000EA8  1               
000EA8  1  A0 02            ldy #2  ; index from payload pointer to width variable (low byte)
000EAA  1  B1 22            lda (ZP_PTR_1),y
000EAC  1  8D 32 09         sta fieldwidth
000EAF  1  A0 04            ldy #4  ; index from payload pointer to height variable (low byte)
000EB1  1  B1 22            lda (ZP_PTR_1),y
000EB3  1  8D 33 09         sta fieldheight
000EB6  1  A0 06            ldy #6  ; index from payload pointer to goals in this level (low byte)
000EB8  1  B1 22            lda (ZP_PTR_1),y
000EBA  1  8D 30 09         sta no_goals
000EBD  1  A0 08            ldy #8  ; index from payload pointer to goals taken in this level (low byte)
000EBF  1  B1 22            lda (ZP_PTR_1),y
000EC1  1  8D 31 09         sta no_goalsreached
000EC4  1  A0 0A            ldy #10  ; index from payload pointer to player offset in this level
000EC6  1               
000EC6  1  B1 22            lda (ZP_PTR_1),y
000EC8  1  18               clc
000EC9  1  69 00            adc #<RAMBANK
000ECB  1  85 26            sta ZP_PTR_3
000ECD  1  C8               iny
000ECE  1  B1 22            lda (ZP_PTR_1),y
000ED0  1  69 A0            adc #>RAMBANK
000ED2  1  85 27            sta ZP_PTR_3+1
000ED4  1                   ; ZP_PTR_3 now contains the actual address in memory of the player, not only the offset from the data
000ED4  1               
000ED4  1                   ; now copy the field data to the RAM bank
000ED4  1  AD 33 09         lda fieldheight
000ED7  1  AA               tax ; create counter
000ED8  1                   ; clear temp counter
000ED8  1  64 30            stz temp
000EDA  1  64 31            stz temp+1
000EDC  1               
000EDC  1               @multiply:
000EDC  1                   ; add fieldwidth variable to temp at each iteration - temp = temp + (width * height)
000EDC  1  A5 30            lda temp
000EDE  1  18               clc
000EDF  1  6D 32 09         adc fieldwidth
000EE2  1  85 30            sta temp
000EE4  1  A5 31            lda temp+1 ; don't forget the high byte
000EE6  1  69 00            adc #0
000EE8  1  85 31            sta temp+1
000EEA  1  CA               dex
000EEB  1  D0 EF            bne @multiply
000EED  1               
000EED  1                   ; copy (temp) amount of bytes from current field pointer to Ram bank 0
000EED  1               
000EED  1                   ; currently ZP_PTR_1 is pointing to the selected field HEADER
000EED  1                   ; retrieve the field pointer from it, and let ZP_PTR_FIELD to that
000EED  1  A0 00            ldy #0
000EEF  1  B1 22            lda (ZP_PTR_1),y
000EF1  1  85 2A            sta ZP_PTR_FIELD
000EF3  1  C8               iny
000EF4  1  B1 22            lda (ZP_PTR_1),y
000EF6  1  85 2B            sta ZP_PTR_FIELD+1
000EF8  1                   ; now let this pointer start counting from LOADSTART, just as the offset in the input file references
000EF8  1  A5 2A            lda ZP_PTR_FIELD
000EFA  1  18               clc
000EFB  1  69 96            adc #<LOADSTART
000EFD  1  85 2A            sta ZP_PTR_FIELD
000EFF  1  A5 2B            lda ZP_PTR_FIELD+1
000F01  1  69 48            adc #>LOADSTART
000F03  1  85 2B            sta ZP_PTR_FIELD+1
000F05  1               
000F05  1                   ; set up destination pointer
000F05  1  A9 00            lda #<RAMBANK
000F07  1  85 24            sta ZP_PTR_2
000F09  1  A9 A0            lda #>RAMBANK
000F0B  1  85 25            sta ZP_PTR_2+1
000F0D  1               
000F0D  1  A0 00            ldy #0
000F0F  1               @copybyte:
000F0F  1                   ; copy one byte of data
000F0F  1  B1 2A            lda (ZP_PTR_FIELD),y
000F11  1  91 24            sta (ZP_PTR_2),y
000F13  1               
000F13  1                   ; temp = temp -1
000F13  1  A5 30            lda temp
000F15  1  38               sec
000F16  1  E9 01            sbc #1
000F18  1  85 30            sta temp
000F1A  1  A5 31            lda temp+1
000F1C  1  E9 00            sbc #0
000F1E  1  85 31            sta temp+1
000F20  1               
000F20  1                   ; if temp==0 done
000F20  1  A5 31            lda temp+1
000F22  1  D0 06            bne @copynextbyte
000F24  1  A5 30            lda temp
000F26  1  D0 02            bne @copynextbyte
000F28  1  80 1C            bra @done
000F2A  1               @copynextbyte:
000F2A  1  A5 2A            lda ZP_PTR_FIELD
000F2C  1  18               clc
000F2D  1  69 01            adc #1
000F2F  1  85 2A            sta ZP_PTR_FIELD
000F31  1  A5 2B            lda ZP_PTR_FIELD+1
000F33  1  69 00            adc #0
000F35  1  85 2B            sta ZP_PTR_FIELD+1
000F37  1  A5 24            lda ZP_PTR_2
000F39  1  18               clc
000F3A  1  69 01            adc #1
000F3C  1  85 24            sta ZP_PTR_2
000F3E  1  A5 25            lda ZP_PTR_2+1
000F40  1  69 00            adc #0
000F42  1  85 25            sta ZP_PTR_2+1
000F44  1  80 C9            bra @copybyte
000F46  1               @done:
000F46  1               
000F46  1                   ; prep the field pointer
000F46  1  A9 00            lda #<RAMBANK
000F48  1  85 2A            sta ZP_PTR_FIELD
000F4A  1  A9 A0            lda #>RAMBANK
000F4C  1  85 2B            sta ZP_PTR_FIELD+1
000F4E  1  60               rts
000F4F  1               
000F4F  1               printfield:
000F4F  1                   ; console routines only
000F4F  1                   ; no clearscreen, just print the field to screen on current position
000F4F  1                   ; depends only on
000F4F  1                   ; - field label for start of field
000F4F  1               
000F4F  1  A5 2A            lda ZP_PTR_FIELD
000F51  1  85 22            sta ZP_PTR_1
000F53  1  A5 2B            lda ZP_PTR_FIELD+1
000F55  1  85 23            sta ZP_PTR_1+1
000F57  1  A2 00            ldx #0 ; row counter
000F59  1               @nextrow:
000F59  1  A0 00            ldy #0 ; column counter
000F5B  1               @row:
000F5B  1  B1 22            lda (ZP_PTR_1),y
000F5D  1  C9 40            cmp #'@'
000F5F  1  F0 06            beq @character
000F61  1  C9 2B            cmp #'+'
000F63  1  F0 02            beq @character
000F65  1  80 17            bra @normalcolor
000F67  1               @character:
000F67  1  48               pha
000F68  1  A9 9E            lda #$9e ; YELLOW
000F6A  1  20 D2 FF         jsr CHROUT
000F6D  1  68               pla
000F6E  1  20 D2 FF         jsr CHROUT
000F71  1  A9 05            lda #$05 ; WHITE
000F73  1  20 D2 FF         jsr CHROUT
000F76  1  C8               iny
000F77  1  CC 32 09         cpy fieldwidth
000F7A  1  D0 DF            bne @row
000F7C  1  80 09            bra @endline
000F7E  1               @normalcolor:
000F7E  1  20 D2 FF         jsr CHROUT
000F81  1  C8               iny
000F82  1  CC 32 09         cpy fieldwidth
000F85  1  D0 D4            bne @row
000F87  1               @endline:
000F87  1  A9 0D            lda #NEWLINE
000F89  1  20 D2 FF         jsr CHROUT
000F8C  1               
000F8C  1                   ; advance pointer to next row
000F8C  1  A5 22            lda ZP_PTR_1
000F8E  1  18               clc
000F8F  1  6D 32 09         adc fieldwidth
000F92  1  85 22            sta ZP_PTR_1
000F94  1  90 07            bcc @checklastrow ; no carry, don't increment high byte on pointer
000F96  1  A5 23            lda ZP_PTR_1+1 ; carry to high byte if carry set ;-)
000F98  1  18               clc
000F99  1  69 01            adc #1
000F9B  1  85 23            sta ZP_PTR_1+1
000F9D  1               @checklastrow:
000F9D  1                   ; last row?
000F9D  1  E8               inx
000F9E  1  EC 33 09         cpx fieldheight
000FA1  1  D0 B6            bne @nextrow
000FA3  1               
000FA3  1                   ; print quit message at the end of the field
000FA3  1  A9 0D            lda #NEWLINE
000FA5  1  20 D2 FF         jsr CHROUT
000FA8  1  A9 79            lda #<quitmessage
000FAA  1  85 22            sta ZP_PTR_1
000FAC  1  A9 08            lda #>quitmessage
000FAE  1  85 23            sta ZP_PTR_1+1
000FB0  1  20 6F 0D         jsr printline
000FB3  1               
000FB3  1  60               rts
000FB4  1               
000FB4  1               cls:
000FB4  1  A9 93            lda #CLEARSCREEN
000FB6  1  20 D2 FF         jsr CHROUT
000FB9  1  60               rts
000FBA  1               
000FBA  1               loadtiles:
000FBA  1               ; Build  16x16 256 color tiles in VRAM location $12000
000FBA  1  9C 25 9F         stz VERA_CTRL                       ; Use Data Register 0
000FBD  1  A9 11            lda #$11
000FBF  1  8D 22 9F         sta VERA_HIGH                       ; Set Increment to 1, High Byte to 1
000FC2  1  A9 20            lda #$20
000FC4  1  8D 21 9F         sta VERA_MID                        ; Set Middle Byte to $20
000FC7  1  9C 20 9F         stz VERA_LOW                        ; Set Low Byte to $00
000FCA  1               
000FCA  1  A2 00            ldx #0
000FCC  1  BD 96 42     :   lda tiledata,x                      ; index 0 / black tile
000FCF  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
000FD2  1  E8               inx
000FD3  1  D0 F7            bne :-
000FD5  1                   ; load Brick data
000FD5  1  A2 00            ldx #0
000FD7  1  BD 96 43     :   lda Brick,x                         ; index 1 / brick
000FDA  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
000FDD  1  E8               inx
000FDE  1  D0 F7            bne :-
000FE0  1                   ; load player data
000FE0  1  A2 00            ldx #0
000FE2  1  BD 96 44     :   lda player,x                        ; index 2 / player
000FE5  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
000FE8  1  E8               inx
000FE9  1  D0 F7            bne :-
000FEB  1                   ; load crate data
000FEB  1  A2 00            ldx #0
000FED  1  BD 96 45     :   lda crate,x                         ; index 3 / crate (normal)
000FF0  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
000FF3  1  E8               inx
000FF4  1  D0 F7            bne :-
000FF6  1                   ; load goal data
000FF6  1  A2 00            ldx #0
000FF8  1  BD 96 46     :   lda goal,x                         ; index 4 / goal (normal)
000FFB  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
000FFE  1  E8               inx
000FFF  1  D0 F7            bne :-
001001  1                   ; load crateongoal data
001001  1  A2 00            ldx #0
001003  1  BD 96 47     :   lda crateongoal,x                   ; index 5 / crate on goal
001006  1  8D 23 9F         sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
001009  1  E8               inx
00100A  1  D0 F7            bne :-
00100C  1               
00100C  1  60               rts
00100D  1               
00100D  1               
00100D  1               displaymessagescreen:
00100D  1                   ; temp store pointer to the requested text
00100D  1  A5 22            lda ZP_PTR_1
00100F  1  48               pha
001010  1  A5 23            lda ZP_PTR_1+1
001012  1  48               pha
001013  1               
001013  1  A9 96            lda #<messagescreen
001015  1  85 22            sta ZP_PTR_1
001017  1  A9 22            lda #>messagescreen
001019  1  85 23            sta ZP_PTR_1+1
00101B  1  20 53 10         jsr displaytileset
00101E  1                   ; now display the string at ZP_PTR_1 in the middle and return
00101E  1  68               pla
00101F  1  85 23            sta ZP_PTR_1+1
001021  1  68               pla
001022  1  85 22            sta ZP_PTR_1
001024  1  9C 25 9F         stz VERA_CTRL
001027  1                   ;lda #%00100000
001027  1  A9 11            lda #$11
001029  1  8D 22 9F         sta VERA_HIGH
00102C  1  A9 CC            lda #204    ; was 28
00102E  1  8D 21 9F         sta VERA_MID
001031  1  A9 38            lda #28*2
001033  1  8D 20 9F         sta VERA_LOW
001036  1  A2 09            ldx #$9 ; color brown
001038  1  20 3C 10         jsr printverastring
00103B  1  60               rts
00103C  1               
00103C  1               printverastring:
00103C  1                   ; ZP_PTR_1 is pointing to the string
00103C  1                   ; x contains color of the text
00103C  1  A0 00            ldy #0
00103E  1               @loop:
00103E  1  B1 22            lda (ZP_PTR_1),y
001040  1  F0 10            beq @end
001042  1  C9 40            cmp #$40
001044  1  90 03            bcc @output
001046  1               @AZ:
001046  1  38               sec
001047  1  E9 40            sbc #$40
001049  1               @output:
001049  1  8D 23 9F         sta VERA_DATA0
00104C  1  8E 23 9F         stx VERA_DATA0
00104F  1  C8               iny
001050  1  80 EC            bra @loop
001052  1               @end:
001052  1  60               rts
001053  1               
001053  1               displaytileset:
001053  1               ; Fill the Layer 0 with the tileset pointed to by ZP_PTR_1
001053  1  9C 25 9F         stz VERA_CTRL                       ; Use Data Register 0
001056  1  A9 10            lda #$10
001058  1  8D 22 9F         sta VERA_HIGH                       ; Set Increment to 1, High Byte to 0
00105B  1  A9 40            lda #$40
00105D  1  8D 21 9F         sta VERA_MID                        ; Set Middle Byte to $40
001060  1  A9 00            lda #$0
001062  1  8D 20 9F         sta VERA_LOW                        ; Set Low Byte to $00
001065  1               
001065  1  A0 20            ldy #32
001067  1               @outerloop:
001067  1  A2 40            ldx #64
001069  1               @innerloop:
001069  1  5A               phy
00106A  1  A0 00            ldy #0
00106C  1  B1 22            lda (ZP_PTR_1),y                    ; load byte from tileset
00106E  1  8D 23 9F         sta VERA_DATA0
001071  1  9C 23 9F         stz VERA_DATA0                      ; zero it's attribute
001074  1  7A               ply
001075  1               
001075  1                   ; increase pointer to next byte in the set
001075  1  A5 22            lda ZP_PTR_1
001077  1  18               clc
001078  1  69 02            adc #$2
00107A  1  85 22            sta ZP_PTR_1
00107C  1  A5 23            lda ZP_PTR_1+1
00107E  1  69 00            adc #$0
001080  1  85 23            sta ZP_PTR_1+1
001082  1               
001082  1  CA               dex
001083  1  D0 E4            bne @innerloop
001085  1  88               dey
001086  1  D0 DF            bne @outerloop
001088  1               
001088  1  60               rts
001089  1               
001089  1               displaytitlescreen:
001089  1  A9 96            lda #<titlescreen
00108B  1  85 22            sta ZP_PTR_1
00108D  1  A9 12            lda #>titlescreen
00108F  1  85 23            sta ZP_PTR_1+1
001091  1  20 53 10         jsr displaytileset
001094  1               
001094  1  9C 25 9F         stz VERA_CTRL
001097  1  A2 09            ldx #$9 ; color brown
001099  1  A9 11            lda #$11
00109B  1  8D 22 9F         sta VERA_HIGH
00109E  1               
00109E  1  A9 A8            lda #<help0
0010A0  1  85 22            sta ZP_PTR_1
0010A2  1  A9 08            lda #>help0
0010A4  1  85 23            sta ZP_PTR_1+1
0010A6  1  A9 C7            lda #199     ; line 23
0010A8  1  8D 21 9F         sta VERA_MID
0010AB  1  A9 64            lda #50*2
0010AD  1  8D 20 9F         sta VERA_LOW
0010B0  1  20 3C 10         jsr printverastring
0010B3  1               
0010B3  1  A9 B6            lda #<help1
0010B5  1  85 22            sta ZP_PTR_1
0010B7  1  A9 08            lda #>help1
0010B9  1  85 23            sta ZP_PTR_1+1
0010BB  1  A9 CE            lda #206     ; line 30
0010BD  1  8D 21 9F         sta VERA_MID
0010C0  1  A9 64            lda #50*2
0010C2  1  8D 20 9F         sta VERA_LOW
0010C5  1  20 3C 10         jsr printverastring
0010C8  1               
0010C8  1  A9 CA            lda #<help2
0010CA  1  85 22            sta ZP_PTR_1
0010CC  1  A9 08            lda #>help2
0010CE  1  85 23            sta ZP_PTR_1+1
0010D0  1  A9 D0            lda #208     ; line 32
0010D2  1  8D 21 9F         sta VERA_MID
0010D5  1  A9 64            lda #50*2
0010D7  1  8D 20 9F         sta VERA_LOW
0010DA  1  20 3C 10         jsr printverastring
0010DD  1               
0010DD  1  A9 E0            lda #<help3
0010DF  1  85 22            sta ZP_PTR_1
0010E1  1  A9 08            lda #>help3
0010E3  1  85 23            sta ZP_PTR_1+1
0010E5  1  A9 D1            lda #209     ; line 33
0010E7  1  8D 21 9F         sta VERA_MID
0010EA  1  A9 64            lda #50*2
0010EC  1  8D 20 9F         sta VERA_LOW
0010EF  1  20 3C 10         jsr printverastring
0010F2  1               
0010F2  1  A9 EE            lda #<help4
0010F4  1  85 22            sta ZP_PTR_1
0010F6  1  A9 08            lda #>help4
0010F8  1  85 23            sta ZP_PTR_1+1
0010FA  1  A9 D2            lda #210     ; line 34
0010FC  1  8D 21 9F         sta VERA_MID
0010FF  1  A9 64            lda #50*2
001101  1  8D 20 9F         sta VERA_LOW
001104  1  20 3C 10         jsr printverastring
001107  1               
001107  1  A9 04            lda #<help5
001109  1  85 22            sta ZP_PTR_1
00110B  1  A9 09            lda #>help5
00110D  1  85 23            sta ZP_PTR_1+1
00110F  1  A9 D3            lda #211     ; line 35
001111  1  8D 21 9F         sta VERA_MID
001114  1  A9 64            lda #50*2
001116  1  8D 20 9F         sta VERA_LOW
001119  1  20 3C 10         jsr printverastring
00111C  1  60               rts
00111D  1               
00111D  1               cleartiles:
00111D  1               ; Fill the Layer 0 with all zeros (black)
00111D  1  9C 25 9F         stz VERA_CTRL                       ; Use Data Register 0
001120  1  A9 10            lda #$10
001122  1  8D 22 9F         sta VERA_HIGH                       ; Set Increment to 1, High Byte to 0
001125  1  A9 40            lda #$40
001127  1  8D 21 9F         sta VERA_MID                        ; Set Middle Byte to $40
00112A  1  A9 00            lda #$0
00112C  1  8D 20 9F         sta VERA_LOW                        ; Set Low Byte to $00
00112F  1               
00112F  1  A0 20            ldy #32
001131  1  A9 00            lda #0
001133  1  A2 40        :   ldx #64
001135  1  8D 23 9F     :   sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
001138  1  8D 23 9F         sta VERA_DATA0                      ; Write Attribute
00113B  1  CA               dex
00113C  1  D0 F7            bne :-
00113E  1  88               dey
00113F  1  D0 F2            bne :--
001141  1               
001141  1  60               rts
001142  1               
001142  1               resetlayerconfig:
001142  1               ; Change Layer 1 to 8 Color Mode
001142  1  AD 34 9F         lda $9F34
001145  1  29 F7            and #%11110111                        ; Set bit 3 to 0, rest unchanged
001147  1  8D 34 9F         sta $9F34
00114A  1               
00114A  1  20 B4 0F         jsr cls
00114D  1  60               rts
00114E  1               
00114E  1               layerconfig:
00114E  1               ; Configure Layer 0
00114E  1  A9 53            lda #%01010011                      ; 64 x 64 tiles, 8 bits per pixel
001150  1  8D 2D 9F         sta $9F2D
001153  1  A9 20            lda #$20                            ; $20 points to $4000 in VRAM
001155  1  8D 2E 9F         sta $9F2E                           ; Store to Map Base Pointer
001158  1               
001158  1  A9 93            lda #$93                            ; $48 points to $12000, Width and Height 16 pixel
00115A  1  8D 2F 9F         sta $9F2F                           ; Store to Tile Base Pointer
00115D  1               
00115D  1  20 1D 11         jsr cleartiles
001160  1               
001160  1               ; Turn on Layer 0
001160  1  AD 29 9F         lda $9F29
001163  1  09 30            ora #%00110000                      ; Bits 4 and 5 are set to 1
001165  1  8D 29 9F         sta $9F29                           ; So both Later 0 and 1 are turned on
001168  1               
001168  1               ; Change Layer 1 to 256 Color Mode
001168  1  AD 34 9F         lda $9F34
00116B  1  09 08            ora #%001000                        ; Set bit 3 to 1, rest unchanged
00116D  1  8D 34 9F         sta $9F34
001170  1               
001170  1               ; Clear Layer 1
001170  1  9C 25 9F         stz VERA_CTRL                       ; Use Data Register 0
001173  1  A9 10            lda #$10
001175  1  8D 22 9F         sta VERA_HIGH                       ; Set Increment to 1, High Byte to 0
001178  1  9C 21 9F         stz VERA_MID                        ; Set Middle Byte to $00
00117B  1  9C 20 9F         stz VERA_LOW                        ; Set Low Byte to $00
00117E  1               
00117E  1  A9 1E            lda #30
001180  1  85 02            sta $02                             ; save counter for rows
001182  1  A0 01            ldy #$01                            ; Color Attribute white on black background
001184  1  A9 20            lda #$20                            ; Blank character
001186  1  A2 00            ldx #0
001188  1  8D 23 9F     :   sta VERA_DATA0                      ; Write to VRAM with +1 Autoincrement
00118B  1  8C 23 9F         sty VERA_DATA0                      ; Write Attribute
00118E  1  E8               inx
00118F  1  D0 F7            bne :-
001191  1  C6 02            dec $02
001193  1  D0 F3            bne :-
001195  1               
001195  1               ; Scale Display x2 for resolution of 320 x 240 pixels
001195  1               ;    lda #$40
001195  1               ;    sta $9F2A
001195  1               ;    sta $9F2B
001195  1               
001195  1  60               rts
001196  1               
001196  1               printfield2:
001196  1               ; prep variables for vera med/high bytes
001196  1               ;    topleft address for first tile is 0x04000
001196  1  A9 40            lda #$40
001198  1  8D 35 09         sta vera_byte_mid
00119B  1  9C 34 09         stz vera_byte_low
00119E  1               
00119E  1               ; shift to the right (SCREENWIDTH - fieldwidth) /2 positions *2 to compensate for attribute
00119E  1  A9 28            lda #SCREENWIDTH
0011A0  1  38               sec
0011A1  1  ED 32 09         sbc fieldwidth
0011A4  1  4A               lsr ; /2
0011A5  1  0A               asl ; *2 - so uneven widths result in an even address and we don't end up in parameter space of the TILEMAP
0011A6  1  8D 34 09         sta vera_byte_low
0011A9  1               
0011A9  1               ; shift down number of rows (SCREENHEIGHT - fieldheight) /2 positions
0011A9  1  A9 1E            lda #SCREENHEIGHT
0011AB  1  38               sec
0011AC  1  ED 33 09         sbc fieldheight
0011AF  1  4A               lsr ; /2
0011B0  1  AA               tax ; transfer number of rows down to counter
0011B1  1               @loop:
0011B1  1  E0 00            cpx #$0 ; any rows down (left)?
0011B3  1  F0 16            beq @done ; exit loop when x == 0
0011B5  1                   ; go 64 tiles further down - 64 * (1 address + 1 parameter of tile) = 128 / $80
0011B5  1  AD 34 09         lda vera_byte_low
0011B8  1  18               clc
0011B9  1  69 80            adc #$80    ; add row <<<ADDRESS>>> height for exactly one row down
0011BB  1  8D 34 09         sta vera_byte_low
0011BE  1  90 08            bcc @decrement  ; no need to change the high byte
0011C0  1  AD 35 09         lda vera_byte_mid
0011C3  1  69 00            adc #$0     ; add carry (so +1)
0011C5  1  8D 35 09         sta vera_byte_mid
0011C8  1               @decrement: ; next row
0011C8  1  CA               dex
0011C9  1  80 E6            bra @loop
0011CB  1               @done:
0011CB  1               
0011CB  1               ; prepare the pointers to the back-end field data, so we know what to display
0011CB  1  A5 2A            lda ZP_PTR_FIELD
0011CD  1  85 22            sta ZP_PTR_1
0011CF  1  A5 2B            lda ZP_PTR_FIELD+1
0011D1  1  85 23            sta ZP_PTR_1+1
0011D3  1               
0011D3  1               ; start displaying the selected field
0011D3  1               ; (vera_byte_mid / vera_byte_low) is the address for the top-left position on-screen in the tile map
0011D3  1  A2 00            ldx #0 ; row counter
0011D5  1               @nextrow:
0011D5  1  A0 00            ldy #0 ; column counter
0011D7  1                   ; prepare vera pointers for this row
0011D7  1  9C 25 9F         stz VERA_CTRL                       ; Use Data Register 0
0011DA  1  A9 10            lda #$10
0011DC  1  8D 22 9F         sta VERA_HIGH                       ; Set Increment to 1, High Byte to 0
0011DF  1  AD 35 09         lda vera_byte_mid
0011E2  1  8D 21 9F         sta VERA_MID
0011E5  1  AD 34 09         lda vera_byte_low
0011E8  1  8D 20 9F         sta VERA_LOW
0011EB  1               
0011EB  1               @row:
0011EB  1                   ; sweep the field, row by row, indexed by column y
0011EB  1  B1 22            lda (ZP_PTR_1),y
0011ED  1  C9 40            cmp #'@'
0011EF  1  F0 2A            beq @player
0011F1  1  C9 2B            cmp #'+'
0011F3  1  F0 26            beq @player
0011F5  1  C9 24            cmp #'$'
0011F7  1  F0 32            beq @crate
0011F9  1  C9 2E            cmp #'.'
0011FB  1  F0 4E            beq @goal
0011FD  1  C9 2A            cmp #'*'
0011FF  1  F0 3A            beq @crateongoal
001201  1  C9 20            cmp #' '
001203  1  F0 06            beq @ignore
001205  1  C9 00            cmp #0
001207  1  F0 02            beq @ignore
001209  1  80 50            bra @wall
00120B  1               @ignore:
00120B  1                   ; ignore
00120B  1  A9 00            lda #$0 ; black tile
00120D  1  8D 23 9F         sta VERA_DATA0
001210  1  9C 23 9F         stz VERA_DATA0
001213  1  C8               iny
001214  1  CC 32 09         cpy fieldwidth
001217  1  D0 D2            bne @row
001219  1  80 4E            bra @endline
00121B  1               @player:
00121B  1  A9 02            lda #$2
00121D  1  8D 23 9F         sta VERA_DATA0
001220  1  9C 23 9F         stz VERA_DATA0
001223  1  C8               iny
001224  1  CC 32 09         cpy fieldwidth
001227  1  D0 C2            bne @row
001229  1  80 3E            bra @endline
00122B  1               @crate:
00122B  1  A9 03            lda #$3
00122D  1  8D 23 9F         sta VERA_DATA0
001230  1  9C 23 9F         stz VERA_DATA0
001233  1  C8               iny
001234  1  CC 32 09         cpy fieldwidth
001237  1  D0 B2            bne @row
001239  1  80 2E            bra @endline
00123B  1               @crateongoal:
00123B  1  A9 05            lda #$5
00123D  1  8D 23 9F         sta VERA_DATA0
001240  1  9C 23 9F         stz VERA_DATA0
001243  1  C8               iny
001244  1  CC 32 09         cpy fieldwidth
001247  1  D0 A2            bne @row
001249  1  80 1E            bra @endline
00124B  1               @goal:
00124B  1  A9 04            lda #$4
00124D  1  8D 23 9F         sta VERA_DATA0
001250  1  9C 23 9F         stz VERA_DATA0
001253  1  C8               iny
001254  1  CC 32 09         cpy fieldwidth
001257  1  D0 92            bne @row
001259  1  80 0E            bra @endline
00125B  1               
00125B  1               @wall:
00125B  1  A9 01            lda #$1 ; load tile 1 ; brick
00125D  1  8D 23 9F         sta VERA_DATA0
001260  1  9C 23 9F         stz VERA_DATA0
001263  1               
001263  1  C8               iny
001264  1  CC 32 09         cpy fieldwidth
001267  1  D0 82            bne @row
001269  1               @endline:
001269  1                   ; advance pointer to next row in the field
001269  1  A5 22            lda ZP_PTR_1
00126B  1  18               clc
00126C  1  6D 32 09         adc fieldwidth
00126F  1  85 22            sta ZP_PTR_1
001271  1  90 06            bcc @checklastrow ; no carry, don't increment high byte on pointer
001273  1  A5 23            lda ZP_PTR_1+1 ; carry to high byte if carry set ;-)
001275  1  69 00            adc #0
001277  1  85 23            sta ZP_PTR_1+1
001279  1               @checklastrow:
001279  1                   ; last row?
001279  1                   ; increment vera pointer to next row
001279  1  AD 34 09         lda vera_byte_low
00127C  1  18               clc
00127D  1  69 80            adc #$80    ; add address delta to next row - 64 tiles * 2 = 128 / $80
00127F  1  8D 34 09         sta vera_byte_low
001282  1  90 08            bcc @next3  ; no need to change the high byte
001284  1  AD 35 09         lda vera_byte_mid
001287  1  69 00            adc #$0     ; add carry (so +1)
001289  1  8D 35 09         sta vera_byte_mid
00128C  1               @next3:
00128C  1  E8               inx
00128D  1  EC 33 09         cpx fieldheight
001290  1  F0 03            beq @nextsection
001292  1               
001292  1  4C D5 11         jmp @nextrow
001295  1               @nextsection:
001295  1  60               rts
001296  1               
001296  1               titlescreen:
001296  1  00 00 01 00  .incbin "tiles/titlescreen.bin"
00129A  1  01 00 01 00  
00129E  1  00 00 00 00  
002296  1               messagescreen:
002296  1  00 00 00 00  .incbin "tiles/messagescreen.bin"
00229A  1  00 00 00 00  
00229E  1  00 00 00 00  
003296  1               completescreen:
003296  1  00 00 00 00  .incbin "tiles/complete.bin"
00329A  1  00 00 00 00  
00329E  1  00 00 00 00  
004296  1               tiledata:
004296  1               black:
004296  1  00 00 00 00  .incbin "tiles/black.bin"
00429A  1  00 00 00 00  
00429E  1  00 00 00 00  
004396  1               Brick:
004396  1  08 08 08 08  .incbin "tiles/brick.bin"
00439A  1  08 08 08 E5  
00439E  1  08 08 08 08  
004496  1               player:
004496  1  00 00 00 00  .incbin "tiles/player.bin"
00449A  1  00 10 10 10  
00449E  1  10 0B 00 00  
004596  1               crate:
004596  1  57 57 57 57  .incbin "tiles/crate.bin"
00459A  1  57 57 57 57  
00459E  1  57 57 57 57  
004696  1               goal:
004696  1  00 00 00 00  .incbin "tiles/goal.bin"
00469A  1  00 00 00 00  
00469E  1  00 00 00 00  
004796  1               crateongoal:
004796  1  57 57 57 57  .incbin "tiles/crateongoal.bin"
00479A  1  57 57 57 57  
00479E  1  57 57 57 57  
004896  1               LOADSTART:
004896  1  32 00 5A 02  .incbin "levels.bin"
00489A  1  0B 00 0B 00  
00489E  1  03 00 00 00  
00829F  1               
00829F  1               
