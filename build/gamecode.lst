ca65 V2.19 - Git fcda94f25
Main file   : src/gamecode.s
Current file: src/gamecode.s

000000r 1               ; constants
000000r 1               LEVELHEADER         = 12
000000r 1               MAXUNDO             = 10
000000r 1               WIDTH_IN_TILES      = 20        ; screen width/height in 16x16 tiles
000000r 1               HEIGHT_IN_TILES     = 15
000000r 1               SCREENWIDTH         = 40       ; actual screenwidth
000000r 1               SCREENHEIGHT        = 30       ; actual screenheight
000000r 1               VIDSTART            = $F800    ; top-left memory address in Cerberus 2080
000000r 1               FIRSTCHAR           = 128      ; first custom character to be part of a tileset
000000r 1               KEY_UP              = $0B
000000r 1               KEY_DOWN            = $0A
000000r 1               KEY_LEFT            = $08
000000r 1               KEY_RIGHT           = $15
000000r 1               KEY_ENTER           = $0D
000000r 1               KEY_Q               = $51
000000r 1               KEY_R               = $52
000000r 1               KEY_M               = $4D
000000r 1               KEY_N               = $4E
000000r 1               KEY_U               = $55
000000r 1               TILE_PLAYER         = $0 ; 16x16 Tile indexes, will later be translated to 8x8 video characters with codes 0-255
000000r 1               TILE_CRATE          = $1
000000r 1               TILE_GOAL           = $2
000000r 1               TILE_CRATE_ON_GOAL  = $3
000000r 1               TILE_WALL           = $4
000000r 1               TILE_IGNORE         = $5
000000r 1               
000000r 1                   .zeropage
000000r 1  xx           xpos:           .res 1
000001r 1  xx           ypos:           .res 1
000002r 1  xx xx        conptr:         .res 2
000004r 1  xx xx        strptr:         .res 2 ; for program use
000006r 1  xx xx        ZP_PTR_1:       .res 2
000008r 1  xx xx        ZP_PTR_2:       .res 2
00000Ar 1  xx xx        ZP_PTR_3:       .res 2  ; position of player
00000Cr 1  xx xx        ZP_PTR_FIELD:   .res 2
00000Er 1  xx xx        ZP_PTR_UNDO:    .res 2  ; used to point to the 'undo stack'
000010r 1  xx xx        temp:           .res 2  ; used for temp 8/16 bit storage, or just local temp variables
000012r 1  xx xx        temp2:          .res 2
000014r 1  xx xx        video:          .res 2
000016r 1               
000016r 1               .setcpu "65C02"
000016r 1               .segment "CODE"
000000r 1               
000000r 1  4C rr rr        jmp start
000003r 1               
000003r 1               ; strings
000003r 1  72 65 61 6C  quitaskmessage:   .byte "really quit? y/n",0
000007r 1  6C 79 20 71  
00000Br 1  75 69 74 3F  
000014r 1  73 65 6C 65  selectmessage:    .byte "select a level (1-",0
000018r 1  63 74 20 61  
00001Cr 1  20 6C 65 76  
000027r 1  29 3A 20 00  selectendmessage: .byte "): ",0
00002Br 1  20 20 20 20  clear:            .byte "                                        ",0
00002Fr 1  20 20 20 20  
000033r 1  20 20 20 20  
000054r 1  72 65 61 6C  resetmessage:     .byte "really reset level? y/n",0
000058r 1  6C 79 20 72  
00005Cr 1  65 73 65 74  
00006Cr 1  70 72 65 73  quitmessage:      .byte "press q to quit",0
000070r 1  73 20 71 20  
000074r 1  74 6F 20 71  
00007Cr 1  6C 65 76 65  winstatement:     .byte "level complete! new level? y/n",0
000080r 1  6C 20 63 6F  
000084r 1  6D 70 6C 65  
00009Br 1  28 63 29 32  help0:            .byte "(c)2022 venom",0
00009Fr 1  30 32 32 20  
0000A3r 1  76 65 6E 6F  
0000A9r 1  6B 65 79 62  help1:            .byte "keyboard shortcuts:",0
0000ADr 1  6F 61 72 64  
0000B1r 1  20 73 68 6F  
0000BDr 1  63 75 72 73  help2:            .byte "cursor - moves player",0
0000C1r 1  6F 72 20 2D  
0000C5r 1  20 6D 6F 76  
0000D3r 1  20 20 20 20  help3:            .byte "     q - quit",0
0000D7r 1  20 71 20 2D  
0000DBr 1  20 71 75 69  
0000E1r 1  20 20 20 20  help4:            .byte "     u - undo move(s)",0
0000E5r 1  20 75 20 2D  
0000E9r 1  20 75 6E 64  
0000F7r 1  20 20 20 20  help5:            .byte "     r - reset level",0
0000FBr 1  20 72 20 2D  
0000FFr 1  20 72 65 73  
00010Cr 1  6D 28 65 6E  done0:            .byte "m(enu)",0
000110r 1  75 29 00     
000113r 1  6E 28 65 78  done1:            .byte "n(ext)",0
000117r 1  74 29 00     
00011Ar 1  71 28 75 69  done2:            .byte "q(uit)",0
00011Er 1  74 29 00     
000121r 1               ; variables that the program uses during execution
000121r 1  00           currentlevel:     .byte 0 ; will need to be filled somewhere in the future in the GUI, or asked from the user
000122r 1  00           no_levels:        .byte 0 ; will be read by initfield
000123r 1  00           no_goals:         .byte 0 ; will be read by initfield, depending on the currentlevel
000124r 1  00           no_goalsreached:  .byte 0 ; static now, reset for each game
000125r 1  00           fieldwidth:       .byte 0 ; will be read by initfield, depending on the currentlevel
000126r 1  00           fieldheight:      .byte 0 ; will be read by initfield, depending on the currentlevel
000127r 1  00 00 00 00  undostack:        .byte 0,0,0,0,0,0,0,0,0,0
00012Br 1  00 00 00 00  
00012Fr 1  00 00        
000131r 1  00           undoindex:        .byte 0
000132r 1  00           undocounter:      .byte 0
000133r 1               
000133r 1               start:
000133r 1                   ; Init stack
000133r 1  A2 FF            ldx #$ff  ; start stack at $1ff
000135r 1  9A               txs       ; init stack pointer (X => SP)
000136r 1               
000136r 1  20 rr rr         jsr resetvars
000139r 1  20 rr rr         jsr con_cls
00013Cr 1               
00013Cr 1                   ; DEBUG CODE
00013Cr 1                  ; show player top-left
00013Cr 1  20 rr rr         jsr loadtiledata
00013Fr 1  A9 80            lda #128
000141r 1  8D 00 F8         sta $F800
000144r 1  A9 81            lda #129
000146r 1  8D 01 F8         sta $F801
000149r 1  A9 82            lda #130
00014Br 1  8D 28 F8         sta $F828
00014Er 1  A9 83            lda #131
000150r 1  8D 29 F8         sta $F829
000153r 1  A9 84            lda #132
000155r 1  8D 02 F8         sta $F802
000158r 1  A9 85            lda #133
00015Ar 1  8D 03 F8         sta $F803
00015Dr 1  A9 86            lda #134
00015Fr 1  8D 2A F8         sta $F82a
000162r 1  A9 87            lda #135
000164r 1  8D 2B F8         sta $F82b
000167r 1  A9 88            lda #136
000169r 1  8D 04 F8         sta $F804
00016Cr 1  A9 89            lda #137
00016Er 1  8D 05 F8         sta $F805
000171r 1  A9 8A            lda #138
000173r 1  8D 2C F8         sta $F82c
000176r 1  A9 8B            lda #139
000178r 1  8D 2D F8         sta $F82d
00017Br 1  A9 8C            lda #140
00017Dr 1  8D 06 F8         sta $F806
000180r 1  A9 8D            lda #141
000182r 1  8D 07 F8         sta $F807
000185r 1  A9 8E            lda #142
000187r 1  8D 2E F8         sta $F82e
00018Ar 1  A9 8F            lda #143
00018Cr 1  8D 2F F8         sta $F82f
00018Fr 1  A9 90            lda #144
000191r 1  8D 08 F8         sta $F808
000194r 1  A9 91            lda #145
000196r 1  8D 09 F8         sta $F809
000199r 1  A9 92            lda #146
00019Br 1  8D 30 F8         sta $F830
00019Er 1  A9 93            lda #147
0001A0r 1  8D 31 F8         sta $F831
0001A3r 1               
0001A3r 1               @loop:
0001A3r 1  80 FE            bra @loop
0001A5r 1               
0001A5r 1                   ; END DEBUG CODE
0001A5r 1  A9 01            lda #$1
0001A7r 1  8D rr rr         sta currentlevel    ; start with level 1
0001AAr 1               
0001AAr 1                   ;jsr displaytitlescreen
0001AAr 1                   ;jsr selectlevel
0001AAr 1                   ;bcc @continue
0001AAr 1                   ;rts                 ; pressed 'q'
0001AAr 1               @continue:
0001AAr 1  20 rr rr         jsr con_cls      ; con_cls tiles
0001ADr 1  20 rr rr         jsr initfield       ; load correct startup values for selected field
0001B0r 1  20 rr rr         jsr printfield2
0001B3r 1               
0001B3r 1               keyloop:
0001B3r 1  20 rr rr         jsr GETIN
0001B6r 1               @checkdown:
0001B6r 1  C9 0A            cmp #KEY_DOWN
0001B8r 1  D0 05            bne @checkup
0001BAr 1  20 rr rr         jsr handledown
0001BDr 1  80 61            bra @done
0001BFr 1               @checkup:
0001BFr 1  C9 0B            cmp #KEY_UP
0001C1r 1  D0 05            bne @checkleft
0001C3r 1  20 rr rr         jsr handleup
0001C6r 1  80 58            bra @done
0001C8r 1               @checkleft:
0001C8r 1  C9 08            cmp #KEY_LEFT
0001CAr 1  D0 05            bne @checkright
0001CCr 1  20 rr rr         jsr handleleft
0001CFr 1  80 4F            bra @done
0001D1r 1               @checkright:
0001D1r 1  C9 15            cmp #KEY_RIGHT
0001D3r 1  D0 05            bne @checkundo
0001D5r 1  20 rr rr         jsr handleright
0001D8r 1  80 46            bra @done
0001DAr 1               @checkundo:
0001DAr 1  C9 55            cmp #KEY_U
0001DCr 1  F0 04            beq @handle_undo
0001DEr 1  C9 75            cmp #(KEY_U | $20) ; lower case
0001E0r 1  D0 05            bne @checkreset
0001E2r 1               @handle_undo:
0001E2r 1  20 rr rr         jsr handle_undocommand
0001E5r 1  80 39            bra @done
0001E7r 1               @checkreset:
0001E7r 1  C9 52            cmp #KEY_R
0001E9r 1  F0 04            beq @handle_reset
0001EBr 1  C9 72            cmp #(KEY_R | $20) ; lower case
0001EDr 1  D0 1B            bne @checkquit
0001EFr 1               @handle_reset:
0001EFr 1  20 rr rr         jsr askreset
0001F2r 1  B0 08            bcs @resetgame
0001F4r 1  20 rr rr         jsr con_cls
0001F7r 1  20 rr rr         jsr printfield2
0001FAr 1  80 24            bra @done
0001FCr 1               @resetgame:
0001FCr 1  20 rr rr         jsr con_cls
0001FFr 1  20 rr rr         jsr resetvars
000202r 1  20 rr rr         jsr initfield
000205r 1  20 rr rr         jsr printfield2
000208r 1  80 A9            bra keyloop
00020Ar 1               @checkquit:
00020Ar 1  C9 51            cmp #KEY_Q
00020Cr 1  F0 04            beq @handle_quit
00020Er 1  C9 71            cmp #(KEY_Q | $20) ; lower case
000210r 1  D0 0E            bne @done
000212r 1               @handle_quit:
000212r 1  20 rr rr         jsr askquit
000215r 1  B0 08            bcs @exit
000217r 1  20 rr rr         jsr con_cls
00021Ar 1  20 rr rr         jsr printfield2
00021Dr 1  80 01            bra @done
00021Fr 1               @exit:
00021Fr 1  60               rts
000220r 1               @done:
000220r 1                   ; check if we have reached all goals
000220r 1  AD rr rr         lda no_goals
000223r 1  CD rr rr         cmp no_goalsreached
000226r 1  D0 2F            bne @donenextkey
000228r 1  20 rr rr         jsr asknewlevel
00022Br 1  C9 4D            cmp #KEY_M ; Menu
00022Dr 1  F0 0E            beq @gotomenu   ; reset game / let user decide on new level
00022Fr 1  C9 6D            cmp #(KEY_M | $20) ; Menu
000231r 1  F0 0A            beq @gotomenu
000233r 1  C9 51            cmp #KEY_Q ; Quit
000235r 1  F0 23            beq @quit
000237r 1  C9 71            cmp #(KEY_Q | $20) ; Quit
000239r 1  F0 1F            beq @quit
00023Br 1  80 03            bra @nextgame
00023Dr 1               @gotomenu:
00023Dr 1  4C rr rr         jmp start
000240r 1               @nextgame:
000240r 1                   ; check if this was the last level
000240r 1  AD rr rr         lda no_levels
000243r 1  CD rr rr         cmp currentlevel
000246r 1  F0 F5            beq @gotomenu   ; select another game
000248r 1  EE rr rr         inc currentlevel ; next level
00024Br 1  20 rr rr         jsr resetvars
00024Er 1  20 rr rr         jsr con_cls
000251r 1               
000251r 1  20 rr rr         jsr initfield       ; load correct startup values for selected field
000254r 1  20 rr rr         jsr printfield2
000257r 1               @donenextkey:
000257r 1  4C rr rr         jmp keyloop
00025Ar 1               @quit:
00025Ar 1  60               rts
00025Br 1               
00025Br 1               GETIN:
00025Br 1  AD 00 02         lda $0200  ; mail flag
00025Er 1  C9 01            cmp #$01    ; character received?
000260r 1  D0 F9            bne GETIN   ; blocked wait for character
000262r 1  9C 00 02         stz $0200  ; acknowledge receive
000265r 1  AD 01 02         lda $0201  ; receive the character from the mailbox slot
000268r 1  60               rts
000269r 1               
000269r 1               handle_undocommand:
000269r 1  20 rr rr         jsr pull_undostack
00026Cr 1                   ; x now contains previous move
00026Cr 1                   ;   as #%000MUDRL - Multiple move / Up / Down / Right / Left
00026Cr 1                   ; we will give x to the handle_undo_**** routine, so it can see the combined bit (4) and act on it
00026Cr 1               @checkup:
00026Cr 1  8A               txa
00026Dr 1  29 08            and #%00001000
00026Fr 1  F0 04            beq @checkdown
000271r 1  20 rr rr         jsr handle_undo_up
000274r 1  60               rts
000275r 1               @checkdown:
000275r 1  8A               txa
000276r 1  29 04            and #%00000100
000278r 1  F0 04            beq @checkright
00027Ar 1  20 rr rr         jsr handle_undo_down
00027Dr 1  60               rts
00027Er 1               @checkright:
00027Er 1  8A               txa
00027Fr 1  29 02            and #%00000010
000281r 1  F0 04            beq @checkleft
000283r 1  20 rr rr         jsr handle_undo_right
000286r 1  60               rts
000287r 1               @checkleft:
000287r 1  8A               txa
000288r 1  29 01            and #%00000001
00028Ar 1  F0 04            beq @emptystack
00028Cr 1  20 rr rr         jsr handle_undo_left
00028Fr 1  60               rts
000290r 1               @emptystack:
000290r 1                   ; do nothing
000290r 1  60               rts
000291r 1               
000291r 1               asknewlevel:
000291r 1                   ; display level complete tilesetj
000291r 1               ;    lda #<completescreen
000291r 1               ;    sta ZP_PTR_1
000291r 1               ;    lda #>completescreen
000291r 1               ;    sta ZP_PTR_1+1
000291r 1               ;    jsr displaytileset
000291r 1               ;
000291r 1               ;    stz VERA_CTRL
000291r 1               ;    ldx #$9 ; color brown
000291r 1               ;    lda #$10
000291r 1               ;    sta VERA_HIGH
000291r 1               ;
000291r 1               ;    lda #<done0
000291r 1               ;    sta ZP_PTR_1
000291r 1               ;    lda #>done0
000291r 1               ;    sta ZP_PTR_1+1
000291r 1               ;    lda #37
000291r 1               ;    sta VERA_MID
000291r 1               ;    lda #38*2
000291r 1               ;    sta VERA_LOW
000291r 1               ;    jsr printverastring
000291r 1               ;
000291r 1               ;    lda #<done1
000291r 1               ;    sta ZP_PTR_1
000291r 1               ;    lda #>done1
000291r 1               ;    sta ZP_PTR_1+1
000291r 1               ;    lda #41
000291r 1               ;    sta VERA_MID
000291r 1               ;    lda #38*2
000291r 1               ;    sta VERA_LOW
000291r 1               ;    jsr printverastring
000291r 1               ;
000291r 1               ;    lda #<done2
000291r 1               ;    sta ZP_PTR_1
000291r 1               ;    lda #>done2
000291r 1               ;    sta ZP_PTR_1+1
000291r 1               ;    lda #45
000291r 1               ;    sta VERA_MID
000291r 1               ;    lda #38*2
000291r 1               ;    sta VERA_LOW
000291r 1               ;    jsr printverastring
000291r 1               
000291r 1               @keyloop:
000291r 1  20 rr rr         jsr GETIN
000294r 1                   ; these lines will filter for 'M / m / N / n / Q / q'
000294r 1  C9 4D            cmp #KEY_M ; M (enu)
000296r 1  F0 16            beq @done
000298r 1  C9 6D            cmp #(KEY_M | $20); lower case
00029Ar 1  F0 12            beq @done
00029Cr 1  C9 4E            cmp #$4E ; N (ext)
00029Er 1  F0 0E            beq @done
0002A0r 1  C9 6E            cmp #(KEY_N | $20) ; lower case
0002A2r 1  F0 0A            beq @done
0002A4r 1  C9 51            cmp #KEY_Q ; Q (uit)
0002A6r 1  F0 06            beq @done
0002A8r 1  C9 71            cmp #(KEY_Q | $20) ; lower case
0002AAr 1  F0 02            beq @done
0002ACr 1  80 E3            bra @keyloop
0002AEr 1               @done:
0002AEr 1  60               rts
0002AFr 1               
0002AFr 1               askquit:
0002AFr 1                   ; ask if the user would like to quit, and return carry on 'y'
0002AFr 1  A9 rr            lda #<quitaskmessage
0002B1r 1  85 rr            sta ZP_PTR_1
0002B3r 1  A9 rr            lda #>quitaskmessage
0002B5r 1  85 rr            sta ZP_PTR_1+1
0002B7r 1  20 rr rr         jsr displaymessagescreen
0002BAr 1               
0002BAr 1               @keyloop:
0002BAr 1  20 rr rr         jsr GETIN
0002BDr 1               @checkyes:
0002BDr 1  C9 59            cmp #$59 ; Y
0002BFr 1  D0 02            bne @checkno
0002C1r 1  38               sec
0002C2r 1  60               rts
0002C3r 1               @checkno:
0002C3r 1  C9 4E            cmp #$4e ; N
0002C5r 1  D0 F3            bne @keyloop
0002C7r 1  18               clc
0002C8r 1  60               rts
0002C9r 1               
0002C9r 1               askreset:
0002C9r 1                   ; ask if the user would like to reset, and return carry on 'y'
0002C9r 1  A9 rr            lda #<resetmessage
0002CBr 1  85 rr            sta ZP_PTR_1
0002CDr 1  A9 rr            lda #>resetmessage
0002CFr 1  85 rr            sta ZP_PTR_1+1
0002D1r 1  20 rr rr         jsr displaymessagescreen
0002D4r 1               
0002D4r 1               @keyloop:
0002D4r 1  20 rr rr         jsr GETIN
0002D7r 1               @checkyes:
0002D7r 1  C9 59            cmp #$59 ; Y
0002D9r 1  D0 02            bne @checkno
0002DBr 1  38               sec
0002DCr 1  60               rts
0002DDr 1               @checkno:
0002DDr 1  C9 4E            cmp #$4e ; N
0002DFr 1  D0 F3            bne @keyloop
0002E1r 1  18               clc
0002E2r 1  60               rts
0002E3r 1               
0002E3r 1               handleright:
0002E3r 1                   ; pointers
0002E3r 1                   ; 3 - player
0002E3r 1                   ; 2 - block to the right of the player
0002E3r 1                   ; 1 - block to the right of that block
0002E3r 1               
0002E3r 1                   ; ZP_PTR_2 = ZP_PTR_3 + 1x position
0002E3r 1  18               clc
0002E4r 1  A5 rr            lda ZP_PTR_3
0002E6r 1  69 01            adc #$1               ; 1x position
0002E8r 1  85 rr            sta ZP_PTR_2
0002EAr 1  A5 rr            lda ZP_PTR_3+1
0002ECr 1  69 00            adc #$0
0002EEr 1  85 rr            sta ZP_PTR_2+1
0002F0r 1               
0002F0r 1                   ; ZP_PTR_1 = ZP_PTR_1 + 2x position
0002F0r 1  18               clc
0002F1r 1  A5 rr            lda ZP_PTR_3
0002F3r 1  69 02            adc #$2               ; 2x position
0002F5r 1  85 rr            sta ZP_PTR_1
0002F7r 1  A5 rr            lda ZP_PTR_3+1
0002F9r 1  69 00            adc #$0
0002FBr 1  85 rr            sta ZP_PTR_1+1
0002FDr 1               
0002FDr 1  A2 02            ldx #%00000010 ; right direction
0002FFr 1  20 rr rr         jsr handlemove
000302r 1  60               rts
000303r 1               
000303r 1               handle_undo_right:
000303r 1                   ; 3 - player
000303r 1               
000303r 1  DA               phx ; store x to stack
000304r 1                   ; point 1 to player
000304r 1               
000304r 1  A5 rr            lda ZP_PTR_3
000306r 1  85 rr            sta ZP_PTR_1
000308r 1  A5 rr            lda ZP_PTR_3+1
00030Ar 1  85 rr            sta ZP_PTR_1+1
00030Cr 1               
00030Cr 1                   ; pointer 2 will point to the left of the player
00030Cr 1                   ; so the player will move back to the left
00030Cr 1  38               sec
00030Dr 1  A5 rr            lda ZP_PTR_3
00030Fr 1  E9 01            sbc #$1
000311r 1  85 rr            sta ZP_PTR_2
000313r 1  A5 rr            lda ZP_PTR_3+1
000315r 1  E9 00            sbc #$0
000317r 1  85 rr            sta ZP_PTR_2+1
000319r 1               
000319r 1  20 rr rr         jsr moveplayeronfield
00031Cr 1  20 rr rr         jsr moveplayerposition
00031Fr 1               
00031Fr 1                   ; check crate move, and if so, move it using pointer 2 -> 1
00031Fr 1  FA               plx
000320r 1  8A               txa
000321r 1  29 10            and #%00010000 ; was a crate moved in this move?
000323r 1  F0 10            beq @done
000325r 1               
000325r 1                   ; load pointer 2 to the right of the previous player's position
000325r 1  18               clc
000326r 1  A5 rr            lda ZP_PTR_1
000328r 1  69 01            adc #$1
00032Ar 1  85 rr            sta ZP_PTR_2
00032Cr 1  A5 rr            lda ZP_PTR_1+1
00032Er 1  69 00            adc #$0
000330r 1  85 rr            sta ZP_PTR_2+1
000332r 1               
000332r 1  20 rr rr         jsr movecrateonfield
000335r 1               @done:
000335r 1  20 rr rr         jsr printfield2
000338r 1  60               rts
000339r 1               
000339r 1               handleleft:
000339r 1                   ; pointers
000339r 1                   ; 3 - player
000339r 1                   ; 2 - block to the left of the player
000339r 1                   ; 1 - block to the left of that block
000339r 1               
000339r 1                   ; ZP_PTR_2 = ZP_PTR_3 - 1x position
000339r 1  38               sec
00033Ar 1  A5 rr            lda ZP_PTR_3
00033Cr 1  E9 01            sbc #$1               ; 1x position
00033Er 1  85 rr            sta ZP_PTR_2
000340r 1  A5 rr            lda ZP_PTR_3+1
000342r 1  E9 00            sbc #$0
000344r 1  85 rr            sta ZP_PTR_2+1
000346r 1               
000346r 1                   ; ZP_PTR_1 = ZP_PTR_1 - 2x position
000346r 1  38               sec
000347r 1  A5 rr            lda ZP_PTR_3
000349r 1  E9 02            sbc #$2               ; 2x position
00034Br 1  85 rr            sta ZP_PTR_1
00034Dr 1  A5 rr            lda ZP_PTR_3+1
00034Fr 1  E9 00            sbc #$0
000351r 1  85 rr            sta ZP_PTR_1+1
000353r 1               
000353r 1  A2 01            ldx #%00000001 ; left direction
000355r 1  20 rr rr         jsr handlemove
000358r 1               
000358r 1               @done:
000358r 1  60               rts
000359r 1               
000359r 1               handle_undo_left:
000359r 1                   ; 3 - player
000359r 1               
000359r 1  DA               phx ; store x to stack
00035Ar 1               
00035Ar 1                   ; point 1 to player
00035Ar 1  A5 rr            lda ZP_PTR_3
00035Cr 1  85 rr            sta ZP_PTR_1
00035Er 1  A5 rr            lda ZP_PTR_3+1
000360r 1  85 rr            sta ZP_PTR_1+1
000362r 1               
000362r 1                   ; pointer 2 will point to the right of the player
000362r 1                   ; so the player will move back to the right
000362r 1  18               clc
000363r 1  A5 rr            lda ZP_PTR_3
000365r 1  69 01            adc #$1
000367r 1  85 rr            sta ZP_PTR_2
000369r 1  A5 rr            lda ZP_PTR_3+1
00036Br 1  69 00            adc #$0
00036Dr 1  85 rr            sta ZP_PTR_2+1
00036Fr 1               
00036Fr 1  20 rr rr         jsr moveplayeronfield
000372r 1  20 rr rr         jsr moveplayerposition
000375r 1               
000375r 1                   ; check crate move, and if so, move it using pointer 2 -> 1
000375r 1  FA               plx
000376r 1  8A               txa
000377r 1  29 10            and #%00010000 ; was a crate moved in this move?
000379r 1  F0 10            beq @done
00037Br 1               
00037Br 1                   ; load pointer 2 to the left of the previous player's position
00037Br 1  38               sec
00037Cr 1  A5 rr            lda ZP_PTR_1
00037Er 1  E9 01            sbc #$1
000380r 1  85 rr            sta ZP_PTR_2
000382r 1  A5 rr            lda ZP_PTR_1+1
000384r 1  E9 00            sbc #$0
000386r 1  85 rr            sta ZP_PTR_2+1
000388r 1               
000388r 1  20 rr rr         jsr movecrateonfield
00038Br 1               @done:
00038Br 1  20 rr rr         jsr printfield2
00038Er 1  60               rts
00038Fr 1               
00038Fr 1               handleup:
00038Fr 1                   ; pointers
00038Fr 1                   ; 3 - player
00038Fr 1                   ; 2 - block to the top of the player
00038Fr 1                   ; 1 - block to the top of that block
00038Fr 1               
00038Fr 1                   ; ZP_PTR_2 = ZP_PTR_3 - 1xFIELDWIDTH
00038Fr 1  AD rr rr         lda fieldwidth
000392r 1  85 rr            sta temp
000394r 1  38               sec
000395r 1  A5 rr            lda ZP_PTR_3
000397r 1  E5 rr            sbc temp
000399r 1  85 rr            sta ZP_PTR_2
00039Br 1  A5 rr            lda ZP_PTR_3+1
00039Dr 1  E9 00            sbc #$0
00039Fr 1  85 rr            sta ZP_PTR_2+1
0003A1r 1               
0003A1r 1                   ; ZP_PTR_1 = ZP_PTR_1 - 2xFIELDWIDTH
0003A1r 1  AD rr rr         lda fieldwidth
0003A4r 1  0A               asl ; 2x
0003A5r 1  85 rr            sta temp
0003A7r 1  38               sec
0003A8r 1  A5 rr            lda ZP_PTR_3
0003AAr 1  E5 rr            sbc temp
0003ACr 1  85 rr            sta ZP_PTR_1
0003AEr 1  A5 rr            lda ZP_PTR_3+1
0003B0r 1  E9 00            sbc #$0
0003B2r 1  85 rr            sta ZP_PTR_1+1
0003B4r 1               
0003B4r 1  A2 08            ldx #%00001000 ; up direction
0003B6r 1  20 rr rr         jsr handlemove
0003B9r 1               
0003B9r 1  60               rts
0003BAr 1               
0003BAr 1               handle_undo_up:
0003BAr 1                   ; 3 - player
0003BAr 1               
0003BAr 1  DA               phx ; store x to stack
0003BBr 1               
0003BBr 1                   ; point 1 to player
0003BBr 1  A5 rr            lda ZP_PTR_3
0003BDr 1  85 rr            sta ZP_PTR_1
0003BFr 1  A5 rr            lda ZP_PTR_3+1
0003C1r 1  85 rr            sta ZP_PTR_1+1
0003C3r 1               
0003C3r 1                   ; pointer 2 will point to the position down of the player
0003C3r 1                   ; so the player will move back down
0003C3r 1  18               clc
0003C4r 1  A5 rr            lda ZP_PTR_3
0003C6r 1  6D rr rr         adc fieldwidth
0003C9r 1  85 rr            sta ZP_PTR_2
0003CBr 1  A5 rr            lda ZP_PTR_3+1
0003CDr 1  69 00            adc #$0
0003CFr 1  85 rr            sta ZP_PTR_2+1
0003D1r 1               
0003D1r 1  20 rr rr         jsr moveplayeronfield
0003D4r 1  20 rr rr         jsr moveplayerposition
0003D7r 1               
0003D7r 1                   ; check crate move, and if so, move it using pointer 2 -> 1
0003D7r 1  FA               plx
0003D8r 1  8A               txa
0003D9r 1  29 10            and #%00010000 ; was a crate moved in this move?
0003DBr 1  F0 11            beq @done
0003DDr 1               
0003DDr 1                   ; load pointer 2 to the top of the previous player's position
0003DDr 1  38               sec
0003DEr 1  A5 rr            lda ZP_PTR_1
0003E0r 1  ED rr rr         sbc fieldwidth
0003E3r 1  85 rr            sta ZP_PTR_2
0003E5r 1  A5 rr            lda ZP_PTR_1+1
0003E7r 1  E9 00            sbc #$0
0003E9r 1  85 rr            sta ZP_PTR_2+1
0003EBr 1               
0003EBr 1  20 rr rr         jsr movecrateonfield
0003EEr 1               @done:
0003EEr 1  20 rr rr         jsr printfield2
0003F1r 1  60               rts
0003F2r 1               
0003F2r 1               handledown:
0003F2r 1                   ; pointers
0003F2r 1                   ; 3 - player
0003F2r 1                   ; 2 - block to the bottom of the player
0003F2r 1                   ; 1 - block to the bottom of that block
0003F2r 1               
0003F2r 1                   ; ZP_PTR_2 = ZP_PTR_3 + 1xFIELDWIDTH
0003F2r 1  AD rr rr         lda fieldwidth
0003F5r 1  85 rr            sta temp
0003F7r 1  18               clc
0003F8r 1  A5 rr            lda ZP_PTR_3
0003FAr 1  65 rr            adc temp
0003FCr 1  85 rr            sta ZP_PTR_2
0003FEr 1  A5 rr            lda ZP_PTR_3+1
000400r 1  69 00            adc #$0
000402r 1  85 rr            sta ZP_PTR_2+1
000404r 1               
000404r 1                   ; ZP_PTR_1 = ZP_PTR_1 + 2xFIELDWIDTH
000404r 1  AD rr rr         lda fieldwidth
000407r 1  0A               asl ; 2x
000408r 1  85 rr            sta temp
00040Ar 1  18               clc
00040Br 1  A5 rr            lda ZP_PTR_3
00040Dr 1  65 rr            adc temp
00040Fr 1  85 rr            sta ZP_PTR_1
000411r 1  A5 rr            lda ZP_PTR_3+1
000413r 1  69 00            adc #$0
000415r 1  85 rr            sta ZP_PTR_1+1
000417r 1               
000417r 1  A2 04            ldx #%00000100 ; down direction
000419r 1  20 rr rr         jsr handlemove
00041Cr 1               
00041Cr 1  60               rts
00041Dr 1               
00041Dr 1               handle_undo_down:
00041Dr 1                   ; 3 - player
00041Dr 1               
00041Dr 1  DA               phx ; store x to stack
00041Er 1               
00041Er 1                   ; point 1 to player
00041Er 1  A5 rr            lda ZP_PTR_3
000420r 1  85 rr            sta ZP_PTR_1
000422r 1  A5 rr            lda ZP_PTR_3+1
000424r 1  85 rr            sta ZP_PTR_1+1
000426r 1               
000426r 1                   ; pointer 2 will point to the position up of the player
000426r 1                   ; so the player will move back up
000426r 1  38               sec
000427r 1  A5 rr            lda ZP_PTR_3
000429r 1  ED rr rr         sbc fieldwidth
00042Cr 1  85 rr            sta ZP_PTR_2
00042Er 1  A5 rr            lda ZP_PTR_3+1
000430r 1  E9 00            sbc #$0
000432r 1  85 rr            sta ZP_PTR_2+1
000434r 1               
000434r 1  20 rr rr         jsr moveplayeronfield
000437r 1  20 rr rr         jsr moveplayerposition
00043Ar 1               
00043Ar 1                   ; check crate move, and if so, move it using pointer 2 -> 1
00043Ar 1  FA               plx
00043Br 1  8A               txa
00043Cr 1  29 10            and #%00010000 ; was a crate moved in this move?
00043Er 1  F0 11            beq @done
000440r 1               
000440r 1                   ; load pointer 2 to the bottom of the previous player's position
000440r 1  18               clc
000441r 1  A5 rr            lda ZP_PTR_1
000443r 1  6D rr rr         adc fieldwidth
000446r 1  85 rr            sta ZP_PTR_2
000448r 1  A5 rr            lda ZP_PTR_1+1
00044Ar 1  69 00            adc #$0
00044Cr 1  85 rr            sta ZP_PTR_2+1
00044Er 1               
00044Er 1  20 rr rr         jsr movecrateonfield
000451r 1               @done:
000451r 1  20 rr rr         jsr printfield2
000454r 1  60               rts
000455r 1               
000455r 1               handlemove:
000455r 1                   ; pointers
000455r 1                   ; 3 - points to the player position
000455r 1                   ; 2 - points to the next block at the indicated direction
000455r 1                   ; 1 - points to the block after that block
000455r 1               
000455r 1  DA               phx ; push x to stack with stored direction
000456r 1               
000456r 1  A0 00            ldy #0
000458r 1  B1 rr            lda (ZP_PTR_2),y
00045Ar 1  C9 20            cmp #' ' ; empty block next to player?
00045Cr 1  F0 06            beq @moveplayertopoint2
00045Er 1  C9 2E            cmp #'.' ; goal position next to player?
000460r 1  F0 02            beq @moveplayertopoint2
000462r 1  80 0C            bra @next ; no ' ' or '.' found next to player, is it a crate or a wall?
000464r 1               @moveplayertopoint2:
000464r 1                   ; move player to pointer 2
000464r 1  20 rr rr         jsr moveplayeronfield
000467r 1  20 rr rr         jsr moveplayerposition
00046Ar 1               
00046Ar 1  FA               plx ; pull direction from the stack
00046Br 1  20 rr rr         jsr push_undostack
00046Er 1  80 2A            bra @movecomplete
000470r 1               @next:
000470r 1  A0 00            ldy #0
000472r 1  B1 rr            lda (ZP_PTR_2),y
000474r 1  C9 24            cmp #'$' ; crate next to player?
000476r 1  F0 06            beq @combinedmovecheck
000478r 1  C9 2A            cmp #'*' ; crate on goal next to player?
00047Ar 1  F0 02            beq @combinedmovecheck
00047Cr 1  80 20            bra @ignore ; something else not able to push
00047Er 1               @combinedmovecheck:
00047Er 1  B1 rr            lda (ZP_PTR_1),y
000480r 1  C9 20            cmp #' ' ; space after crate?
000482r 1  F0 06            beq @combinedmove
000484r 1  C9 2E            cmp #'.' ; goal after crate?
000486r 1  F0 02            beq @combinedmove
000488r 1  80 14            bra @ignore ; nothing to move
00048Ar 1               @combinedmove:
00048Ar 1  20 rr rr         jsr movecrateonfield
00048Dr 1  20 rr rr         jsr moveplayeronfield
000490r 1  20 rr rr         jsr moveplayerposition
000493r 1               
000493r 1                   ; record combined move to undo stack
000493r 1  68               pla
000494r 1  09 10            ora #%00010000   ; set 'combined' bit 4
000496r 1  AA               tax
000497r 1  20 rr rr         jsr push_undostack
00049Ar 1               
00049Ar 1               @movecomplete:
00049Ar 1  20 rr rr         jsr printfield2
00049Dr 1  60               rts
00049Er 1               
00049Er 1               @ignore: ; nothing to move
00049Er 1  FA               plx  ; don't forget to remove the stacked x move
00049Fr 1  60               rts
0004A0r 1               
0004A0r 1               push_undostack:
0004A0r 1                   ; record single move to undo stack
0004A0r 1                   ; x contains direction and single/multiple move
0004A0r 1                   ; x = 0%000MUDRL - Multiple / Up / Down / Right / Left
0004A0r 1                   ;
0004A0r 1                   ; the stack index 'pointer' undoindex points to a new entry each time
0004A0r 1  8A               txa
0004A1r 1  AC rr rr         ldy undoindex
0004A4r 1  91 rr            sta (ZP_PTR_UNDO),y
0004A6r 1               
0004A6r 1  C0 09            cpy #MAXUNDO-1 ; at last physical item in memory? then loop around
0004A8r 1  F0 05            beq @loopindex
0004AAr 1  EE rr rr         inc undoindex
0004ADr 1  80 03            bra @checkmaxcount
0004AFr 1                @loopindex:
0004AFr 1  9C rr rr         stz undoindex
0004B2r 1                @checkmaxcount:
0004B2r 1  AD rr rr         lda undocounter
0004B5r 1  C9 0A            cmp #MAXUNDO
0004B7r 1  F0 03            beq @done ; maximum count reached / stack will loop around
0004B9r 1  EE rr rr         inc undocounter
0004BCr 1                @done:
0004BCr 1  60               rts
0004BDr 1               
0004BDr 1               pull_undostack:
0004BDr 1                   ; remove single move from undo stack
0004BDr 1                   ; afterwards, x contains direction and single/multiple move
0004BDr 1                   ; x = 0%000MUDRL - Multiple / Up / Down / Right / Left
0004BDr 1               
0004BDr 1  AD rr rr         lda undocounter ; check if we have any moves pushed to the stack
0004C0r 1  D0 03            bne @stackedmoves
0004C2r 1  A2 00            ldx #$0 ; empty move, nothing in the stack
0004C4r 1  60               rts
0004C5r 1               
0004C5r 1               @stackedmoves:
0004C5r 1  CE rr rr         dec undocounter ; reduce the number pushed to the stack with 1
0004C8r 1  AC rr rr         ldy undoindex
0004CBr 1  C0 00            cpy #$0 ; index at first position?
0004CDr 1  D0 04            bne @normalindex
0004CFr 1  A0 09            ldy #MAXUNDO-1 ; move it to the 'previous' index position in a circular manner
0004D1r 1  80 01            bra @next
0004D3r 1               @normalindex:
0004D3r 1  88               dey ; move it to the 'previous' index position
0004D4r 1               @next:
0004D4r 1  8C rr rr         sty undoindex
0004D7r 1                   ; y now points to the previous move, as an index to the stack memory
0004D7r 1  B1 rr            lda (ZP_PTR_UNDO),y
0004D9r 1  AA               tax
0004DAr 1  60               rts
0004DBr 1               
0004DBr 1               moveplayerposition:
0004DBr 1                   ; moves pointer 3 to position of pointer 2
0004DBr 1  A5 rr            lda ZP_PTR_2
0004DDr 1  85 rr            sta ZP_PTR_3
0004DFr 1  A5 rr            lda ZP_PTR_2+1
0004E1r 1  85 rr            sta ZP_PTR_3+1
0004E3r 1  60               rts
0004E4r 1               
0004E4r 1               movecrateonfield:
0004E4r 1                   ; copies (ZP_PTR_2) to (ZP_PTR_1)
0004E4r 1                   ; and handles different crate move options (normal / crate on goal)
0004E4r 1  A0 00            ldy #0
0004E6r 1  B1 rr            lda (ZP_PTR_2),y
0004E8r 1                   ; was there a goal underneath the crate?
0004E8r 1  C9 2A            cmp #'*'
0004EAr 1  D0 1D            bne @crateonly
0004ECr 1                   ; do we move to a goal position? (from goal to goal..)
0004ECr 1  B1 rr            lda (ZP_PTR_1),y
0004EEr 1  C9 2E            cmp #'.'
0004F0r 1  D0 0A            bne @movetonormalposition
0004F2r 1               @movetogoalposition:
0004F2r 1  A9 2A            lda #'*' ; crate on goal symbol
0004F4r 1  91 rr            sta (ZP_PTR_1),y
0004F6r 1  A9 2E            lda #'.'
0004F8r 1  91 rr            sta (ZP_PTR_2),y
0004FAr 1  80 28            bra @done
0004FCr 1               @movetonormalposition:
0004FCr 1  CE rr rr         dec no_goalsreached ; -1 win points
0004FFr 1  A9 24            lda #'$'; crate symbol
000501r 1  91 rr            sta (ZP_PTR_1),y
000503r 1  A9 2E            lda #'.'
000505r 1  91 rr            sta (ZP_PTR_2),y
000507r 1  80 1B            bra @done
000509r 1               @crateonly:
000509r 1                   ; is the destination a goal?
000509r 1  B1 rr            lda (ZP_PTR_1),y
00050Br 1  C9 2E            cmp #'.'
00050Dr 1  D0 0D            bne @crateonly_nongoal
00050Fr 1                   ; crate moves to goal, from a non-goal position
00050Fr 1  EE rr rr         inc no_goalsreached ; +1 to win
000512r 1  A9 2A            lda #'*'
000514r 1  91 rr            sta (ZP_PTR_1),y
000516r 1  A9 20            lda #' '
000518r 1  91 rr            sta (ZP_PTR_2),y
00051Ar 1  80 08            bra @done
00051Cr 1               @crateonly_nongoal:
00051Cr 1  A9 24            lda #'$'
00051Er 1  91 rr            sta (ZP_PTR_1),y
000520r 1  A9 20            lda #' '; empty space to move the player in next
000522r 1  91 rr            sta (ZP_PTR_2),y
000524r 1               @done:
000524r 1  60               rts
000525r 1               
000525r 1               moveplayeronfield:
000525r 1                   ; copies (ZP_PTR_3) to (ZP_PTR_2)
000525r 1                   ; and handles multiple player move options (normal / on goal)
000525r 1  A0 00            ldy #0
000527r 1  B1 rr            lda (ZP_PTR_3),y
000529r 1                   ; was there a goal underneath the player?
000529r 1  C9 2B            cmp #'+'
00052Br 1  D0 1A            bne @playeronly
00052Dr 1                   ; do we move to a goal position? (from goal to goal..)
00052Dr 1  B1 rr            lda (ZP_PTR_2),y
00052Fr 1  C9 2E            cmp #'.'
000531r 1  D0 0A            bne @movetonormalposition
000533r 1               @movetogoalposition:
000533r 1  A9 2B            lda #'+' ; player on goal symbol
000535r 1  91 rr            sta (ZP_PTR_2),y
000537r 1  A9 2E            lda #'.'
000539r 1  91 rr            sta (ZP_PTR_3),y
00053Br 1  80 22            bra @done
00053Dr 1               @movetonormalposition:
00053Dr 1  A9 40            lda #'@'; player symbol
00053Fr 1  91 rr            sta (ZP_PTR_2),y
000541r 1  A9 2E            lda #'.'
000543r 1  91 rr            sta (ZP_PTR_3),y
000545r 1  80 18            bra @done
000547r 1               @playeronly:
000547r 1                   ; is the destination a goal?
000547r 1  B1 rr            lda (ZP_PTR_2),y
000549r 1  C9 2E            cmp #'.'
00054Br 1  D0 0A            bne @playeronly_nongoal
00054Dr 1                   ; player moves to goal, from a non-goal position
00054Dr 1  A9 2B            lda #'+'
00054Fr 1  91 rr            sta (ZP_PTR_2),y
000551r 1  A9 20            lda #' '
000553r 1  91 rr            sta (ZP_PTR_3),y
000555r 1  80 08            bra @done
000557r 1               @playeronly_nongoal:
000557r 1  A9 40            lda #'@'
000559r 1  91 rr            sta (ZP_PTR_2),y
00055Br 1  A9 20            lda #' '; empty space
00055Dr 1  91 rr            sta (ZP_PTR_3),y
00055Fr 1               @done:
00055Fr 1  60               rts
000560r 1               
000560r 1               printdecimal:
000560r 1                   ; prints decimal from A register
000560r 1                   ; VERA control needs to be set up previously
000560r 1  DA               phx
000561r 1  5A               phy
000562r 1  86 rr            stx temp    ; keep color to print in
000564r 1  A0 2F            ldy #$2f
000566r 1  A2 3A            ldx #$3a
000568r 1  38               sec
000569r 1               @loop1:
000569r 1  C8               iny
00056Ar 1  E9 64            sbc #100
00056Cr 1  B0 FB            bcs @loop1
00056Er 1               @loop2:
00056Er 1  CA               dex
00056Fr 1  69 0A            adc #10
000571r 1  30 FB            bmi @loop2
000573r 1  69 2F            adc #$2f
000575r 1               
000575r 1                   ; Y = hundreds, X = tens, A = ones
000575r 1  48               pha
000576r 1  8A               txa
000577r 1  48               pha
000578r 1  98               tya
000579r 1  C9 30            cmp #$30 ; is it a '0' petscii?
00057Br 1  F0 00            beq @tens
00057Dr 1               ;    sta VERA_DATA0
00057Dr 1               ;    lda temp
00057Dr 1               ;    sta VERA_DATA0
00057Dr 1               @tens:
00057Dr 1  68               pla
00057Er 1  C9 30            cmp #$30 ; is it a '0' petscii?
000580r 1  F0 00            beq @ones
000582r 1               ;    sta VERA_DATA0
000582r 1               ;    lda temp
000582r 1               ;    sta VERA_DATA0
000582r 1               @ones:
000582r 1  68               pla
000583r 1               ;    sta VERA_DATA0
000583r 1               ;    lda temp
000583r 1               ;    sta VERA_DATA0
000583r 1               
000583r 1  7A               ply
000584r 1  FA               plx
000585r 1  60               rts
000586r 1               
000586r 1               selectlevel:
000586r 1  A9 01            lda #1 ; start out with first level
000588r 1  8D rr rr         sta currentlevel
00058Br 1               
00058Br 1               @mainloop:
00058Br 1  20 rr rr         jsr clearselect
00058Er 1                   ; text prep to VERA
00058Er 1               ;    stz VERA_CTRL
00058Er 1               ;    ldx #$9 ; color brown
00058Er 1               ;    lda #$10
00058Er 1               ;    sta VERA_HIGH
00058Er 1               ;    lda #<selectmessage
00058Er 1               ;    sta ZP_PTR_1
00058Er 1               ;    lda #>selectmessage
00058Er 1               ;    sta ZP_PTR_1+1
00058Er 1               ;    lda #45
00058Er 1               ;    sta VERA_MID
00058Er 1               ;    lda #10*2
00058Er 1               ;    sta VERA_LOW
00058Er 1               ;    jsr printverastring
00058Er 1               
00058Er 1                   ; print range
00058Er 1  AD rr rr         lda no_levels
000591r 1  20 rr rr         jsr printdecimal
000594r 1  A9 rr            lda #<selectendmessage
000596r 1  85 rr            sta ZP_PTR_1
000598r 1  A9 rr            lda #>selectendmessage
00059Ar 1  85 rr            sta ZP_PTR_1+1
00059Cr 1  20 rr rr         jsr printverastring
00059Fr 1                   ; print level number
00059Fr 1  AD rr rr         lda currentlevel
0005A2r 1  20 rr rr         jsr printdecimal
0005A5r 1               
0005A5r 1               @charloop:
0005A5r 1  20 rr rr         jsr GETIN
0005A8r 1               @checkdown:
0005A8r 1  C9 11            cmp #$11 ; down pressed
0005AAr 1  F0 06            beq @down
0005ACr 1  C9 9D            cmp #$9d ; left pressed
0005AEr 1  F0 02            beq @down
0005B0r 1  80 0C            bra @checkup
0005B2r 1               @down:
0005B2r 1                   ; down key pressed
0005B2r 1  AD rr rr         lda currentlevel
0005B5r 1  C9 01            cmp #1
0005B7r 1  F0 EC            beq @charloop   ; lowest value == 1
0005B9r 1  CE rr rr         dec currentlevel
0005BCr 1  80 CD            bra @mainloop
0005BEr 1               @checkup:
0005BEr 1  C9 91            cmp #$91 ; up pressed
0005C0r 1  F0 06            beq @up
0005C2r 1  C9 1D            cmp #$1d ; right pressed
0005C4r 1  F0 02            beq @up
0005C6r 1  80 0D            bra @checkreturnkey
0005C8r 1               @up:
0005C8r 1                   ; up key pressed
0005C8r 1  AD rr rr         lda currentlevel
0005CBr 1  CD rr rr         cmp no_levels
0005CEr 1  F0 D5            beq @charloop   ; maximum value reached
0005D0r 1  EE rr rr         inc currentlevel
0005D3r 1  80 B6            bra @mainloop
0005D5r 1               @checkreturnkey:
0005D5r 1  C9 0D            cmp #$0d
0005D7r 1  D0 01            bne @checkquit
0005D9r 1                   ; return key pressed - select this level
0005D9r 1  60               rts
0005DAr 1               @checkquit:
0005DAr 1  C9 51            cmp #$51
0005DCr 1  D0 C7            bne @charloop
0005DEr 1  38               sec ; set carry to notify caller
0005DFr 1  60               rts
0005E0r 1               resetvars:
0005E0r 1                   ; reset goals
0005E0r 1  A9 00            lda #0
0005E2r 1  8D rr rr         sta no_goalsreached
0005E5r 1               
0005E5r 1                   ; load field pointer to first address at LOADSTART
0005E5r 1                   ; load 1st pointer to temp pointer ZP_PTR_1
0005E5r 1  A9 rr            lda #<LOADSTART
0005E7r 1  85 rr            sta ZP_PTR_1
0005E9r 1  A9 rr            lda #>LOADSTART
0005EBr 1  85 rr            sta ZP_PTR_1+1
0005EDr 1               
0005EDr 1                   ; load number of levels, pointed to by ZP_PTR_1,0
0005EDr 1  A0 00            ldy #0
0005EFr 1  B1 rr            lda (ZP_PTR_1),y
0005F1r 1  8D rr rr         sta no_levels
0005F4r 1               
0005F4r 1                   ; reset undo stack
0005F4r 1  A9 rr            lda #<undostack
0005F6r 1  85 rr            sta ZP_PTR_UNDO
0005F8r 1  A9 rr            lda #>undostack
0005FAr 1  85 rr            sta ZP_PTR_UNDO+1
0005FCr 1               
0005FCr 1  9C rr rr         stz undoindex
0005FFr 1  9C rr rr         stz undocounter
000602r 1  60               rts
000603r 1               
000603r 1               clearselect:
000603r 1                   ; clear out select text first
000603r 1               ;    stz VERA_CTRL
000603r 1  A2 09            ldx #$9
000605r 1  A9 10            lda #$10
000607r 1               ;    sta VERA_HIGH
000607r 1  A9 rr            lda #<clear
000609r 1  85 rr            sta ZP_PTR_1
00060Br 1  A9 rr            lda #>clear
00060Dr 1  85 rr            sta ZP_PTR_1+1
00060Fr 1  A9 2D            lda #45
000611r 1               ;    sta VERA_MID
000611r 1  A9 14            lda #10*2
000613r 1               ;    sta VERA_LOW
000613r 1  20 rr rr         jsr printverastring
000616r 1  60               rts
000617r 1               
000617r 1               initfield:
000617r 1                   ; load field pointer to first address at LOADSTART
000617r 1                   ; load 1st pointer to temp pointer ZP_PTR_1
000617r 1  A9 rr            lda #<LOADSTART
000619r 1  85 rr            sta ZP_PTR_1
00061Br 1  A9 rr            lda #>LOADSTART
00061Dr 1  85 rr            sta ZP_PTR_1+1
00061Fr 1               
00061Fr 1                   ; skip to the first header, two bytes next
00061Fr 1  18               clc
000620r 1  A5 rr            lda ZP_PTR_1
000622r 1  69 02            adc #2
000624r 1  85 rr            sta ZP_PTR_1
000626r 1               
000626r 1                   ; now advance pointer (currentlevel - 1) * HEADERSIZE to advance to the correct payload pointer to that level
000626r 1  AD rr rr         lda currentlevel
000629r 1  AA               tax ; x contains the currentlevel now and will act as a counter
00062Ar 1               @loop:
00062Ar 1  CA               dex
00062Br 1  F0 11            beq @fieldptrdone
00062Dr 1                   ; advance the field payload pointer
00062Dr 1  A5 rr            lda ZP_PTR_1
00062Fr 1  18               clc
000630r 1  69 0C            adc #LEVELHEADER
000632r 1  85 rr            sta ZP_PTR_1
000634r 1  90 F4            bcc @loop   ; nothing to do for the high byte
000636r 1  A5 rr            lda ZP_PTR_1+1
000638r 1  69 00            adc #$0     ; increase the high byte
00063Ar 1  85 rr            sta ZP_PTR_1+1
00063Cr 1  80 EC            bra @loop
00063Er 1               @fieldptrdone:
00063Er 1               
00063Er 1  A0 02            ldy #2  ; index from payload pointer to width variable (low byte)
000640r 1  B1 rr            lda (ZP_PTR_1),y
000642r 1  8D rr rr         sta fieldwidth
000645r 1  A0 04            ldy #4  ; index from payload pointer to height variable (low byte)
000647r 1  B1 rr            lda (ZP_PTR_1),y
000649r 1  8D rr rr         sta fieldheight
00064Cr 1  A0 06            ldy #6  ; index from payload pointer to goals in this level (low byte)
00064Er 1  B1 rr            lda (ZP_PTR_1),y
000650r 1  8D rr rr         sta no_goals
000653r 1  A0 08            ldy #8  ; index from payload pointer to goals taken in this level (low byte)
000655r 1  B1 rr            lda (ZP_PTR_1),y
000657r 1  8D rr rr         sta no_goalsreached
00065Ar 1  A0 0A            ldy #10  ; index from payload pointer to player offset in this level
00065Cr 1               
00065Cr 1  B1 rr            lda (ZP_PTR_1),y
00065Er 1  18               clc
00065Fr 1  69 rr            adc #<RAMBANK
000661r 1  85 rr            sta ZP_PTR_3
000663r 1  C8               iny
000664r 1  B1 rr            lda (ZP_PTR_1),y
000666r 1  69 rr            adc #>RAMBANK
000668r 1  85 rr            sta ZP_PTR_3+1
00066Ar 1                   ; ZP_PTR_3 now contains the actual address in memory of the player, not only the offset from the data
00066Ar 1               
00066Ar 1                   ; now copy the field data to the RAM bank
00066Ar 1  AD rr rr         lda fieldheight
00066Dr 1  AA               tax ; create counter
00066Er 1                   ; clear temp counter
00066Er 1  64 rr            stz temp
000670r 1  64 rr            stz temp+1
000672r 1               
000672r 1               @multiply:
000672r 1                   ; add fieldwidth variable to temp at each iteration - temp = temp + (width * height)
000672r 1  A5 rr            lda temp
000674r 1  18               clc
000675r 1  6D rr rr         adc fieldwidth
000678r 1  85 rr            sta temp
00067Ar 1  A5 rr            lda temp+1 ; don't forget the high byte
00067Cr 1  69 00            adc #0
00067Er 1  85 rr            sta temp+1
000680r 1  CA               dex
000681r 1  D0 EF            bne @multiply
000683r 1               
000683r 1                   ; copy (temp) amount of bytes from current field pointer to Ram bank 0
000683r 1               
000683r 1                   ; currently ZP_PTR_1 is pointing to the selected field HEADER
000683r 1                   ; retrieve the field pointer from it, and let ZP_PTR_FIELD to that
000683r 1  A0 00            ldy #0
000685r 1  B1 rr            lda (ZP_PTR_1),y
000687r 1  85 rr            sta ZP_PTR_FIELD
000689r 1  C8               iny
00068Ar 1  B1 rr            lda (ZP_PTR_1),y
00068Cr 1  85 rr            sta ZP_PTR_FIELD+1
00068Er 1                   ; now let this pointer start counting from LOADSTART, just as the offset in the input file references
00068Er 1  A5 rr            lda ZP_PTR_FIELD
000690r 1  18               clc
000691r 1  69 rr            adc #<LOADSTART
000693r 1  85 rr            sta ZP_PTR_FIELD
000695r 1  A5 rr            lda ZP_PTR_FIELD+1
000697r 1  69 rr            adc #>LOADSTART
000699r 1  85 rr            sta ZP_PTR_FIELD+1
00069Br 1               
00069Br 1                   ; set up destination pointer
00069Br 1  A9 rr            lda #<RAMBANK
00069Dr 1  85 rr            sta ZP_PTR_2
00069Fr 1  A9 rr            lda #>RAMBANK
0006A1r 1  85 rr            sta ZP_PTR_2+1
0006A3r 1               
0006A3r 1  A0 00            ldy #0
0006A5r 1               @copybyte:
0006A5r 1                   ; copy one byte of data
0006A5r 1  B1 rr            lda (ZP_PTR_FIELD),y
0006A7r 1  91 rr            sta (ZP_PTR_2),y
0006A9r 1               
0006A9r 1                   ; temp = temp -1
0006A9r 1  A5 rr            lda temp
0006ABr 1  38               sec
0006ACr 1  E9 01            sbc #1
0006AEr 1  85 rr            sta temp
0006B0r 1  A5 rr            lda temp+1
0006B2r 1  E9 00            sbc #0
0006B4r 1  85 rr            sta temp+1
0006B6r 1               
0006B6r 1                   ; if temp==0 done
0006B6r 1  A5 rr            lda temp+1
0006B8r 1  D0 06            bne @copynextbyte
0006BAr 1  A5 rr            lda temp
0006BCr 1  D0 02            bne @copynextbyte
0006BEr 1  80 1C            bra @done
0006C0r 1               @copynextbyte:
0006C0r 1  A5 rr            lda ZP_PTR_FIELD
0006C2r 1  18               clc
0006C3r 1  69 01            adc #1
0006C5r 1  85 rr            sta ZP_PTR_FIELD
0006C7r 1  A5 rr            lda ZP_PTR_FIELD+1
0006C9r 1  69 00            adc #0
0006CBr 1  85 rr            sta ZP_PTR_FIELD+1
0006CDr 1  A5 rr            lda ZP_PTR_2
0006CFr 1  18               clc
0006D0r 1  69 01            adc #1
0006D2r 1  85 rr            sta ZP_PTR_2
0006D4r 1  A5 rr            lda ZP_PTR_2+1
0006D6r 1  69 00            adc #0
0006D8r 1  85 rr            sta ZP_PTR_2+1
0006DAr 1  80 C9            bra @copybyte
0006DCr 1               @done:
0006DCr 1               
0006DCr 1                   ; prep the field pointer
0006DCr 1  A9 rr            lda #<RAMBANK
0006DEr 1  85 rr            sta ZP_PTR_FIELD
0006E0r 1  A9 rr            lda #>RAMBANK
0006E2r 1  85 rr            sta ZP_PTR_FIELD+1
0006E4r 1  60               rts
0006E5r 1               
0006E5r 1               displaymessagescreen:
0006E5r 1                   ; temp store pointer to the requested text
0006E5r 1  A5 rr            lda ZP_PTR_1
0006E7r 1  48               pha
0006E8r 1  A5 rr            lda ZP_PTR_1+1
0006EAr 1  48               pha
0006EBr 1               
0006EBr 1  A9 rr            lda #<messagescreen
0006EDr 1  85 rr            sta ZP_PTR_1
0006EFr 1  A9 rr            lda #>messagescreen
0006F1r 1  85 rr            sta ZP_PTR_1+1
0006F3r 1  20 rr rr         jsr displaytileset
0006F6r 1                   ; now display the string at ZP_PTR_1 in the middle and return
0006F6r 1  68               pla
0006F7r 1  85 rr            sta ZP_PTR_1+1
0006F9r 1  68               pla
0006FAr 1  85 rr            sta ZP_PTR_1
0006FCr 1               ;    stz VERA_CTRL
0006FCr 1                   ;lda #%00100000
0006FCr 1  A9 10            lda #$10
0006FEr 1               ;    sta VERA_HIGH
0006FEr 1  A9 1C            lda #28
000700r 1               ;    sta VERA_MID
000700r 1  A9 38            lda #28*2
000702r 1               ;    sta VERA_LOW
000702r 1  A2 09            ldx #$9 ; color brown
000704r 1  20 rr rr         jsr printverastring
000707r 1  60               rts
000708r 1               
000708r 1               printverastring:
000708r 1                   ; ZP_PTR_1 is pointing to the string
000708r 1                   ; x contains color of the text
000708r 1  A0 00            ldy #0
00070Ar 1               @loop:
00070Ar 1  B1 rr            lda (ZP_PTR_1),y
00070Cr 1  F0 0A            beq @end
00070Er 1  C9 40            cmp #$40
000710r 1  90 03            bcc @output
000712r 1               @AZ:
000712r 1  38               sec
000713r 1  E9 40            sbc #$40
000715r 1               @output:
000715r 1               ;    sta VERA_DATA0
000715r 1               ;    stx VERA_DATA0
000715r 1  C8               iny
000716r 1  80 F2            bra @loop
000718r 1               @end:
000718r 1  60               rts
000719r 1               
000719r 1               displaytileset:
000719r 1               ; Fill the Layer 0 with the tileset pointed to by ZP_PTR_1
000719r 1               ;    stz VERA_CTRL                       ; Use Data Register 0
000719r 1  A9 10            lda #$10
00071Br 1               ;    sta VERA_HIGH                       ; Set Increment to 1, High Byte to 0
00071Br 1  A9 40            lda #$40
00071Dr 1               ;    sta VERA_MID                        ; Set Middle Byte to $40
00071Dr 1  A9 00            lda #$0
00071Fr 1               ;    sta VERA_LOW                        ; Set Low Byte to $00
00071Fr 1               
00071Fr 1  A0 20            ldy #32
000721r 1               @outerloop:
000721r 1  A2 40            ldx #64
000723r 1               @innerloop:
000723r 1  5A               phy
000724r 1  A0 00            ldy #0
000726r 1  B1 rr            lda (ZP_PTR_1),y                    ; load byte from tileset
000728r 1               ;    sta VERA_DATA0
000728r 1               ;    stz VERA_DATA0                      ; zero it's attribute
000728r 1  7A               ply
000729r 1               
000729r 1                   ; increase pointer to next byte in the set
000729r 1  A5 rr            lda ZP_PTR_1
00072Br 1  18               clc
00072Cr 1  69 02            adc #$2
00072Er 1  85 rr            sta ZP_PTR_1
000730r 1  A5 rr            lda ZP_PTR_1+1
000732r 1  69 00            adc #$0
000734r 1  85 rr            sta ZP_PTR_1+1
000736r 1               
000736r 1  CA               dex
000737r 1  D0 EA            bne @innerloop
000739r 1  88               dey
00073Ar 1  D0 E5            bne @outerloop
00073Cr 1               
00073Cr 1  60               rts
00073Dr 1               
00073Dr 1               displaytitlescreen:
00073Dr 1  A9 rr            lda #<titlescreen
00073Fr 1  85 rr            sta ZP_PTR_1
000741r 1  A9 rr            lda #>titlescreen
000743r 1  85 rr            sta ZP_PTR_1+1
000745r 1  20 rr rr         jsr displaytileset
000748r 1               
000748r 1               ;    stz VERA_CTRL
000748r 1  A2 09            ldx #$9 ; color brown
00074Ar 1  A9 10            lda #$10
00074Cr 1               ;    sta VERA_HIGH
00074Cr 1               
00074Cr 1  A9 rr            lda #<help0
00074Er 1  85 rr            sta ZP_PTR_1
000750r 1  A9 rr            lda #>help0
000752r 1  85 rr            sta ZP_PTR_1+1
000754r 1  A9 17            lda #23
000756r 1               ;    sta VERA_MID
000756r 1  A9 64            lda #50*2
000758r 1               ;    sta VERA_LOW
000758r 1  20 rr rr         jsr printverastring
00075Br 1               
00075Br 1  A9 rr            lda #<help1
00075Dr 1  85 rr            sta ZP_PTR_1
00075Fr 1  A9 rr            lda #>help1
000761r 1  85 rr            sta ZP_PTR_1+1
000763r 1  A9 1E            lda #30
000765r 1               ;    sta VERA_MID
000765r 1  A9 64            lda #50*2
000767r 1               ;    sta VERA_LOW
000767r 1  20 rr rr         jsr printverastring
00076Ar 1               
00076Ar 1  A9 rr            lda #<help2
00076Cr 1  85 rr            sta ZP_PTR_1
00076Er 1  A9 rr            lda #>help2
000770r 1  85 rr            sta ZP_PTR_1+1
000772r 1  A9 20            lda #32
000774r 1               ;    sta VERA_MID
000774r 1  A9 64            lda #50*2
000776r 1               ;    sta VERA_LOW
000776r 1  20 rr rr         jsr printverastring
000779r 1               
000779r 1  A9 rr            lda #<help3
00077Br 1  85 rr            sta ZP_PTR_1
00077Dr 1  A9 rr            lda #>help3
00077Fr 1  85 rr            sta ZP_PTR_1+1
000781r 1  A9 21            lda #33
000783r 1               ;    sta VERA_MID
000783r 1  A9 64            lda #50*2
000785r 1               ;    sta VERA_LOW
000785r 1  20 rr rr         jsr printverastring
000788r 1               
000788r 1  A9 rr            lda #<help4
00078Ar 1  85 rr            sta ZP_PTR_1
00078Cr 1  A9 rr            lda #>help4
00078Er 1  85 rr            sta ZP_PTR_1+1
000790r 1  A9 22            lda #34
000792r 1               ;    sta VERA_MID
000792r 1  A9 64            lda #50*2
000794r 1               ;    sta VERA_LOW
000794r 1  20 rr rr         jsr printverastring
000797r 1               
000797r 1  A9 rr            lda #<help5
000799r 1  85 rr            sta ZP_PTR_1
00079Br 1  A9 rr            lda #>help5
00079Dr 1  85 rr            sta ZP_PTR_1+1
00079Fr 1  A9 23            lda #35
0007A1r 1               ;    sta VERA_MID
0007A1r 1  A9 64            lda #50*2
0007A3r 1               ;    sta VERA_LOW
0007A3r 1  20 rr rr         jsr printverastring
0007A6r 1  60               rts
0007A7r 1               
0007A7r 1               
0007A7r 1               loadtiledata:
0007A7r 1                   ; loads tile data into character memory, starting from FIRSTCHAR
0007A7r 1  A9 00            lda #00
0007A9r 1  85 rr            sta temp
0007ABr 1  A9 F4            lda #$f4        ; $F400 = F000 + (128 * 8) - start of FIRSTCHAR definition
0007ADr 1  85 rr            sta temp+1     ; temp is the destination into video character memory
0007AFr 1               
0007AFr 1  A9 rr            lda #<tiledata
0007B1r 1  85 rr            sta temp2
0007B3r 1  A9 rr            lda #>tiledata
0007B5r 1  85 rr            sta temp2+1    ; temp2 is the source of the data
0007B7r 1               
0007B7r 1  A2 00            ldx #0
0007B9r 1  A0 00            ldy #0
0007BBr 1               @loop:
0007BBr 1  B1 rr            lda (temp2),y
0007BDr 1  91 rr            sta (temp),y
0007BFr 1  E8               inx
0007C0r 1                   ; +1 to both pointers
0007C0r 1  18               clc
0007C1r 1  A5 rr            lda temp
0007C3r 1  69 01            adc #1
0007C5r 1  85 rr            sta temp
0007C7r 1  A5 rr            lda temp+1
0007C9r 1  69 00            adc #0
0007CBr 1  85 rr            sta temp+1
0007CDr 1               
0007CDr 1  18               clc
0007CEr 1  A5 rr            lda temp2
0007D0r 1  69 01            adc #1
0007D2r 1  85 rr            sta temp2
0007D4r 1  A5 rr            lda temp2+1
0007D6r 1  69 00            adc #0
0007D8r 1  85 rr            sta temp2+1
0007DAr 1               
0007DAr 1  E0 C0            cpx #(6 * 16 * 2)   ; 6 tiles times 16 x 16 bit, or 6 * 16 * 2 byte
0007DCr 1  D0 DD            bne @loop
0007DEr 1  60               rts
0007DFr 1               
0007DFr 1               printfield2:
0007DFr 1  A9 00            lda #$00    ; low byte for video start
0007E1r 1  85 rr            sta video
0007E3r 1  A9 F8            lda #$f8    ; high byte for video start
0007E5r 1  85 rr            sta video+1
0007E7r 1               
0007E7r 1               ; Calculate start address
0007E7r 1               ; first calculate TX and TY (Tile (X,Y) position)
0007E7r 1               ; Center field within WIDTH_IN_TILES first
0007E7r 1               ; shift to the right (WIDTH_IN_TILES - fieldwidth) /2 positions
0007E7r 1  A9 14            lda #WIDTH_IN_TILES
0007E9r 1  38               sec
0007EAr 1  ED rr rr         sbc fieldwidth
0007EDr 1  4A               lsr ; /2
0007EEr 1                   ; A now contains Tile X position (TX)
0007EEr 1  AA               tax         ; save TX
0007EFr 1               ; Center field vertically within HEIGHT_IN_TILES next
0007EFr 1               ; Shift down (HEIGHT_IN_TILES - fieldheight) / 2 positions
0007EFr 1  A9 0F            lda #HEIGHT_IN_TILES
0007F1r 1  38               sec
0007F2r 1  ED rr rr         sbc fieldheight
0007F5r 1  4A               lsr ; /2
0007F6r 1                   ; A now contains Tile Y position (TY)
0007F6r 1               ; Now calculate video start position
0007F6r 1               ; Video start = (TY*80) + (TX * 2)
0007F6r 1               ;             = (TY * 64) + (TY * 16) + (TX * 2)
0007F6r 1               ;             = (TY << 6) + (TY << 4) + (TX << 1)
0007F6r 1  0A               asl ; starting with TY, left in A from previous code
0007F7r 1  0A               asl
0007F8r 1  0A               asl
0007F9r 1  0A               asl
0007FAr 1  0A               asl
0007FBr 1  0A               asl
0007FCr 1  85 rr            sta temp    ; temp now contains TY << 6
0007FEr 1  0A               asl
0007FFr 1  0A               asl
000800r 1  0A               asl
000801r 1  0A               asl
000802r 1  0A               asl ; A contains TY << 4
000803r 1  18               clc
000804r 1  65 rr            adc temp
000806r 1  85 rr            sta temp    ; temp now contains (TY << 6) + (TY << 4)
000808r 1  8A               txa         ; retrieve TX
000809r 1  0A               asl         ; * 2
00080Ar 1  18               clc
00080Br 1  65 rr            adc temp    ; A now contains video start address
00080Dr 1  85 rr            sta video
00080Fr 1               
00080Fr 1               ; prepare the pointers to the back-end field data, so we know what to display
00080Fr 1  A5 rr            lda ZP_PTR_FIELD
000811r 1  85 rr            sta ZP_PTR_1
000813r 1  A5 rr            lda ZP_PTR_FIELD+1
000815r 1  85 rr            sta ZP_PTR_1+1
000817r 1               
000817r 1               ; start displaying the selected field
000817r 1               ; temp2 contains a loop counter for the actual display rows
000817r 1  A9 00            lda #0
000819r 1  85 rr            sta temp2
00081Br 1               
00081Br 1  A2 00            ldx #0 ; 0 == top row of 16x16 tile, 10 == bottom row of 16x16 tile
00081Dr 1               @nextrow:
00081Dr 1  A0 00            ldy #0 ; column counter
00081Fr 1               @col:
00081Fr 1                   ; sweep the field, row by row, indexed by column y
00081Fr 1                   ; inputs are: y (column and also (y >> 1) == high/low byte in tile)
00081Fr 1                   ;             x top/bottom row in tile
00081Fr 1                   ; returns quarter tile as video code index in A
00081Fr 1  20 rr rr         jsr get_tilequarter
000822r 1  91 rr            sta (video),y
000824r 1  C8               iny
000825r 1  CC rr rr         cpy fieldwidth
000828r 1  D0 F5            bne @col
00082Ar 1               @checkrow:
00082Ar 1  A5 rr            lda temp2
00082Cr 1  18               clc
00082Dr 1  69 01            adc #1
00082Fr 1  85 rr            sta temp2   ; increase display row counter
000831r 1  CD rr rr         cmp fieldheight
000834r 1  F0 1B            beq @done
000836r 1                   ; xor x
000836r 1  E0 00            cpx #0
000838r 1  F0 04            beq @xto1
00083Ar 1  A2 00            ldx #0
00083Cr 1  80 02            bra @xordone
00083Er 1               @xto1:
00083Er 1  A2 01            ldx #1
000840r 1               @xordone:
000840r 1                   ; next row, add 40 to video
000840r 1  A5 rr            lda video
000842r 1  18               clc
000843r 1  69 28            adc #SCREENWIDTH
000845r 1  85 rr            sta video
000847r 1  90 D4            bcc @nextrow
000849r 1  A5 rr            lda video+1
00084Br 1  69 00            adc #0
00084Dr 1  85 rr            sta video+1
00084Fr 1  80 CC            bra @nextrow
000851r 1               @done:
000851r 1  60               rts
000852r 1               
000852r 1               get_tilequarter:
000852r 1                   ; inputs:
000852r 1                   ; x,y,Z_PTR_1
000852r 1  DA               phx
000853r 1  5A               phy
000854r 1               
000854r 1  B1 rr            lda (ZP_PTR_1),y    ; obtain content in field position
000856r 1  C9 40            cmp #'@'
000858r 1  F0 1A            beq @player
00085Ar 1  C9 2B            cmp #'+'
00085Cr 1  F0 16            beq @player
00085Er 1  C9 24            cmp #'$'
000860r 1  F0 16            beq @crate
000862r 1  C9 2E            cmp #'.'
000864r 1  F0 16            beq @goal
000866r 1  C9 2A            cmp #'*'
000868r 1  F0 16            beq @crateongoal
00086Ar 1  C9 20            cmp #' '
00086Cr 1  F0 16            beq @ignore
00086Er 1  C9 00            cmp #0
000870r 1  F0 12            beq @ignore
000872r 1  80 14            bra @wall
000874r 1               
000874r 1               @player:
000874r 1  A9 00            lda #TILE_PLAYER
000876r 1  80 14            bra @tiled
000878r 1               @crate:
000878r 1  A9 01            lda #TILE_CRATE
00087Ar 1  80 10            bra @tiled
00087Cr 1               @goal:
00087Cr 1  A9 02            lda #TILE_GOAL
00087Er 1  80 0C            bra @tiled
000880r 1               @crateongoal:
000880r 1  A9 03            lda #TILE_CRATE_ON_GOAL
000882r 1  80 08            bra @tiled
000884r 1               @ignore:
000884r 1  A9 05            lda #TILE_IGNORE
000886r 1  80 04            bra @tiled
000888r 1               @wall:
000888r 1  A9 04            lda #TILE_WALL
00088Ar 1  80 00            bra @tiled
00088Cr 1               
00088Cr 1               @tiled:
00088Cr 1                   ; calculate offset in tile first
00088Cr 1                   ; top-left:  y = 0, x = 0
00088Cr 1                   ; top-right: y = 1, x = 0
00088Cr 1                   ; btm-left:  y = 0, x = else (high bit)
00088Cr 1                   ; btm-right: y = 1, x = else (high bit)
00088Cr 1  84 rr            sty temp ; store low bit for later addition into A
00088Er 1  8A               txa
00088Fr 1  C9 00            cmp #0
000891r 1  F0 02            beq @hibitdone
000893r 1                   ; x was <> 0, so make it 10
000893r 1  A9 0A            lda #10
000895r 1               @hibitdone:
000895r 1  18               clc
000896r 1  65 rr            adc temp    ; A now contains offset into tile originally pointed to by y. Range is 0 - 3 ($00 - $11)
000898r 1               
000898r 1                   ; tile 0: video characters 128,129,130,131. So 128 + 0-3
000898r 1  69 80            adc #FIRSTCHAR    ; character number 128 is top-left 8x8 of tile 0, add the 0-3 index to it previously calculated
00089Ar 1  85 rr            sta temp
00089Cr 1  7A               ply        ; return tile ID
00089Dr 1  98               tya
00089Er 1  0A               asl
00089Fr 1  0A               asl        ; tile ID*4(8x8)
0008A0r 1  65 rr            adc temp   ; A now contains the actual video character to display at this 8x8 quarter in the larger 16x16
0008A2r 1  FA               plx
0008A3r 1  60               rts
0008A4r 1               
0008A4r 1               con_init:
0008A4r 1                   ; initializes the console variables
0008A4r 1                   ; reset to X,Y = 0,0
0008A4r 1  48               pha
0008A5r 1  DA               phx
0008A6r 1  5A               phy
0008A7r 1  64 rr            stz xpos
0008A9r 1  64 rr            stz ypos
0008ABr 1  A9 00            lda #<VIDSTART
0008ADr 1  85 rr            sta conptr
0008AFr 1  A9 F8            lda #>VIDSTART
0008B1r 1  85 rr            sta conptr+1
0008B3r 1  7A               ply
0008B4r 1  FA               plx
0008B5r 1  68               pla
0008B6r 1  60               rts
0008B7r 1               
0008B7r 1               con_cls:
0008B7r 1                   ; Fill the entire screen with empty tile (space)
0008B7r 1                   ; and reset console to 0,0
0008B7r 1  48               pha
0008B8r 1  DA               phx
0008B9r 1  5A               phy
0008BAr 1  20 rr rr         jsr con_init
0008BDr 1               
0008BDr 1  A2 00            ldx #$0
0008BFr 1               @outer:
0008BFr 1  A9 20            lda #' '            ; space character
0008C1r 1  A0 00            ldy #$0
0008C3r 1               @inner:
0008C3r 1  91 rr            sta (conptr),y
0008C5r 1  C8               iny
0008C6r 1  C0 28            cpy #SCREENWIDTH
0008C8r 1  D0 F9            bne @inner          ; next column
0008CAr 1  18               clc
0008CBr 1  A5 rr            lda conptr
0008CDr 1  69 28            adc #SCREENWIDTH             ; next row
0008CFr 1  85 rr            sta conptr
0008D1r 1  90 06            bcc @next
0008D3r 1  A5 rr            lda conptr+1
0008D5r 1  69 00            adc #$0             ; add the carry (1) to the high byte
0008D7r 1  85 rr            sta conptr+1
0008D9r 1               @next:
0008D9r 1  E8               inx
0008DAr 1  E0 1E            cpx #SCREENHEIGHT
0008DCr 1  D0 E1            bne @outer
0008DEr 1               
0008DEr 1  20 rr rr         jsr con_init
0008E1r 1  7A               ply
0008E2r 1  FA               plx
0008E3r 1  68               pla
0008E4r 1  60               rts
0008E5r 1               
0008E5r 1               con_gotox:
0008E5r 1  48               pha
0008E6r 1  DA               phx
0008E7r 1  5A               phy
0008E8r 1  A4 rr            ldy ypos
0008EAr 1  20 rr rr         jsr con_gotoxy
0008EDr 1  7A               ply
0008EEr 1  FA               plx
0008EFr 1  68               pla
0008F0r 1  60               rts
0008F1r 1               
0008F1r 1               con_gotoxy:
0008F1r 1                   ; input .x == x position
0008F1r 1                   ; input .y == y position
0008F1r 1  48               pha
0008F2r 1  DA               phx
0008F3r 1  5A               phy
0008F4r 1  E0 28            cpx #SCREENWIDTH
0008F6r 1  B0 2B            bcs @done           ; >= to WIDTH, set carry and exit
0008F8r 1  C0 1E            cpy #SCREENHEIGHT
0008FAr 1  B0 27            bcs @done           ; >= to HEIGHT, set carry and exit
0008FCr 1  86 rr            stx xpos
0008FEr 1  84 rr            sty ypos
000900r 1               
000900r 1  A9 28            lda #SCREENWIDTH
000902r 1  85 rr            sta conptr      ; FAC1 == conptr(low), FAC2 = ypos. FAC1 gets clobbered to final low byte of result
000904r 1                   ; multiply ypos * SCREENWIDTH, store in conptr
000904r 1               @mul8:
000904r 1  A9 00            lda #$00
000906r 1  A2 08            ldx #$08
000908r 1  18               clc
000909r 1               @m0:
000909r 1  90 03            bcc @m1
00090Br 1  18               clc
00090Cr 1  65 rr            adc ypos
00090Er 1               @m1:
00090Er 1  6A               ror
00090Fr 1  66 rr            ror conptr
000911r 1  CA               dex
000912r 1  10 F5            bpl @m0
000914r 1  85 rr            sta conptr+1
000916r 1                   ; result now in conptr / conptr+1
000916r 1                   ; Add both video start address (F800) and xpos to conptr.
000916r 1                   ; As xpos <40, we can use the low byte immediately
000916r 1  18               clc
000917r 1  A5 rr            lda conptr
000919r 1  65 rr            adc xpos
00091Br 1  85 rr            sta conptr
00091Dr 1  A5 rr            lda conptr+1
00091Fr 1  69 F8            adc #$F8
000921r 1  85 rr            sta conptr+1
000923r 1               @done:
000923r 1  7A               ply
000924r 1  FA               plx
000925r 1  68               pla
000926r 1  60               rts
000927r 1               
000927r 1               con_print:
000927r 1                   ; prints zero-terminated string pointed to by strptr in zeropage
000927r 1  48               pha
000928r 1  DA               phx
000929r 1  5A               phy
00092Ar 1               
00092Ar 1  A0 00            ldy #0
00092Cr 1               @loop:
00092Cr 1  B1 rr            lda (strptr),y
00092Er 1  F0 06            beq @done
000930r 1  20 rr rr         jsr con_printchar
000933r 1  C8               iny
000934r 1  80 F6            bra @loop
000936r 1               @done:
000936r 1  7A               ply
000937r 1  FA               plx
000938r 1  68               pla
000939r 1  60               rts
00093Ar 1               
00093Ar 1               con_printchar:
00093Ar 1                   ; prints character from A to the current X,Y coordinate in zeropage
00093Ar 1                   ; X,Y is always a previously checked valid coordinate
00093Ar 1  48               pha
00093Br 1  DA               phx
00093Cr 1  5A               phy
00093Dr 1               
00093Dr 1  C9 0D            cmp #$d ; CR
00093Fr 1  F0 15            beq @CRLF
000941r 1  C9 0A            cmp #$a ; LF
000943r 1  F0 11            beq @CRLF
000945r 1               
000945r 1                   ; print normally
000945r 1  A0 00            ldy #0
000947r 1  91 rr            sta (conptr),y
000949r 1                   ; update position and check validity
000949r 1                   ; wrap around at end of screen to 0,0
000949r 1                   ; X = X + 1
000949r 1  A5 rr            lda xpos
00094Br 1  C9 27            cmp #SCREENWIDTH-1
00094Dr 1  F0 07            beq @CRLF
00094Fr 1  18               clc
000950r 1  69 01            adc #1
000952r 1  85 rr            sta xpos
000954r 1  80 21            bra @nextptr
000956r 1               @CRLF:
000956r 1  A9 28            lda #SCREENWIDTH
000958r 1  38               sec
000959r 1  E5 rr            sbc xpos            ; move down SCREENWIDTH - xpos characters
00095Br 1  18               clc
00095Cr 1  65 rr            adc conptr          ; add to low byte of pointer
00095Er 1  85 rr            sta conptr
000960r 1  A5 rr            lda conptr+1
000962r 1  69 00            adc #0
000964r 1  85 rr            sta conptr+1        ; add to high byte of pointer
000966r 1               
000966r 1                   ; now reset x and check y next
000966r 1  64 rr            stz xpos
000968r 1  A5 rr            lda ypos
00096Ar 1  C9 1D            cmp #SCREENHEIGHT-1
00096Cr 1  D0 05            bne @nextrow
00096Er 1                   ; return to 0,0
00096Er 1  20 rr rr         jsr con_init
000971r 1  80 13            bra @done
000973r 1               @nextrow:
000973r 1  E6 rr            inc ypos
000975r 1  80 0F            bra @done
000977r 1               @nextptr:
000977r 1  A5 rr            lda conptr
000979r 1  18               clc
00097Ar 1  69 01            adc #1
00097Cr 1  85 rr            sta conptr
00097Er 1  90 06            bcc @done
000980r 1  A5 rr            lda conptr+1
000982r 1  69 00            adc #0
000984r 1  85 rr            sta conptr+1
000986r 1               @done:
000986r 1  7A               ply
000987r 1  FA               plx
000988r 1  68               pla
000989r 1  60               rts
00098Ar 1               
00098Ar 1               titlescreen:
00098Ar 1  00 00 01 00  .incbin "tiles/titlescreen.bin"
00098Er 1  01 00 01 00  
000992r 1  00 00 00 00  
00198Ar 1               messagescreen:
00198Ar 1  00 00 00 00  .incbin "tiles/messagescreen.bin"
00198Er 1  00 00 00 00  
001992r 1  00 00 00 00  
00298Ar 1               completescreen:
00298Ar 1  00 00 00 00  .incbin "tiles/complete.bin"
00298Er 1  00 00 00 00  
002992r 1  00 00 00 00  
00398Ar 1               
00398Ar 1               ; tile data
00398Ar 1               ; each tile consists of 16x16, 4x8x8 laid out sequentially
00398Ar 1               ; this will need to be loaded dynamically into character memory at program start
00398Ar 1               tiledata:
00398Ar 1               player:
00398Ar 1  01 03 04 0A      .byte $1,$3,$4,$A,$8,$5,$4,$3,$80,$C0,$20,$50,$10,$A0,$20,$C0,$6,$F,$E,$1B,$3,$2,$6,$E,$60,$F0,$70,$D8,$C0,$40,$60,$70
00398Er 1  08 05 04 03  
003992r 1  80 C0 20 50  
0039AAr 1               crate:
0039AAr 1  00 77 48 44      .byte $0,$77,$48,$44,$22,$51,$48,$44,$0,$EE,$12,$22,$44,$8A,$12,$22,$44,$48,$51,$22,$44,$48,$77,$0,$22,$12,$8A,$44,$22,$12,$EE,$0
0039AEr 1  22 51 48 44  
0039B2r 1  00 EE 12 22  
0039CAr 1               goal:
0039CAr 1  00 00 04 02      .byte $0,$0,$4,$2,$1,$20,$10,$9,$0,$0,$20,$40,$80,$4,$8,$90,$9,$10,$20,$1,$2,$4,$0,$0,$90,$8,$4,$80,$40,$20,$0,$0
0039CEr 1  01 20 10 09  
0039D2r 1  00 00 20 40  
0039EAr 1               crateongoal:
0039EAr 1  00 77 68 54      .byte $0,$77,$68,$54,$2A,$55,$4A,$45,$0,$EE,$16,$2A,$54,$AA,$52,$A2,$45,$4A,$55,$2A,$54,$68,$77,$0,$A2,$52,$AA,$54,$2A,$16,$EE,$0
0039EEr 1  2A 55 4A 45  
0039F2r 1  00 EE 16 2A  
003A0Ar 1               brick:
003A0Ar 1  EF AA EF 00      .byte $EF,$AA,$EF,$0,$FE,$AA,$FE,$0,$EF,$AA,$EF,$0,$FE,$AA,$FE,$0,$EF,$AA,$EF,$0,$FE,$AA,$FE,$0,$EF,$AA,$EF,$0,$FE,$AA,$FE,$0
003A0Er 1  FE AA FE 00  
003A12r 1  EF AA EF 00  
003A2Ar 1               black:
003A2Ar 1  00 00 00 00      .byte $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003A2Er 1  00 00 00 00  
003A32r 1  00 00 00 00  
003A4Ar 1               LOADSTART:
003A4Ar 1  15 00 FE 00  .incbin "levels.bin"
003A4Er 1  0B 00 0B 00  
003A52r 1  03 00 00 00  
004791r 1               RAMBANK:    ; Start of variable DATA, used for copying new field into
004791r 1               
